 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 1 - 19/03/25 16:29:15


       1/   0 :                         ; -----------------------------------------------------------------------------
       2/   0 :                         ; SPDX-FileCopyrightText: © 2024 Damir Maleničić,
       3/   0 :                         ; SPDX-License-Identifier: MIT
       4/   0 :                         ; -----------------------------------------------------------------------------
       5/   0 :                         ; This program generates all prime numbers less than 65536 using a sieve of
       6/   0 :                         ; Eratosthenes algorithm.
       7/   0 :                         ; -----------------------------------------------------------------------------
       8/   0 :                         ; Register allocation is partially imposed by the integration with Chuck's monitor:
       9/   0 :                         ; R0 - reset program counter and SP, PC, and SP for user programs invoked with the
      10/   0 :                         ;      `R` command, a memory pointer during the `DMA` transfer
      11/   0 :                         ; R1 - the interrupt program counter
      12/   0 :                         ; R2 - a stack pointer for the main function and interrupt routines
      13/   0 :                         ; R3 - program counter for the main function
      14/   0 :                         ; R4 - program counter for SCRT subroutine calls
      15/   0 :                         ; R5 - program counter for SCRT subroutine returns
      16/   0 :                         ; R6 - SCRT return address stack pointer
      17/   0 :                         ; R7 - a pointer to a string to be written when invoking `mon_put_str` on location 8526
      18/   0 :                         ; R8, R9.LO are used to update the context of `sieve` (step 3.2)
      19/   0 :                         ;     R8 points to the byte, and R9.LO is the bit mask to test/update
      20/   0 :                         ; RA holds the pointer to the buffer that holds the current number being
      21/   0 :                         ;     marked as composite, or
      22/   0 :                         ; RC holds the current number being tested for primality
      23/   0 :                         ; RD holds the pointer to the `step` when marking multiples of a prime number as composites
      24/   0 :                         ; RB.HI - holds the input character classification
      25/   0 :                         ; RB.LO - holds the input character or the output character
      26/   0 :                         ; RE.HI - by the monitor program convention, it holds 01
      27/   0 :                         ; RE.LO - holds the UART baud rate indicator
      28/   0 :                         ; RF.HI - used by SCRT call and return subroutines to preserve the value of D
      29/   0 :                         ;         register between caller and callee
      30/   0 :                         ; -----------------------------------------------------------------------------
      31/   0 :                         ; It is assembled using
      32/   0 :                         ; [The Macro Assembler AS](http://john.ccac.rwth-aachen.de:8000/as/), but
      33/   0 :                         ; the code should be portable to other 1802 assemblers.
      34/   0 :                         ; The following instructions can be used to assemble and link the program:
      35/   0 :                         ; ```
      36/   0 :                         ; asl -cpu 1802 -L sieve.asm
      37/   0 :                         ; p2hex 8-queens.p sieve.hex
      38/   0 :                         ; ```
      39/   0 :                         ; -----------------------------------------------------------------------------
      40/   0 :                         
      41/   0 :                         
      42/   0 :                         ; enable C style numeric constants --------------------------------------------
      43/   0 :                         
      44/   0 :                         
      45/   0 :                                 RELAXED ON
      46/   0 :                         
      47/   0 :                                 CPU     1802
      48/   0 :                         
      49/   0 :                         
      50/   0 :                         ; include the bit manipulation functions --------------------------------------
      51/   0 :                         ; This file defines some bit-oriented functions that might be hardwired
      52/   0 :                         ; when using other assemblers.
      53/   0 :                         ; A code uses `hi()` and `lo()` operators that `asl` implements as user-defined
      54/   0 :                         ; function. `$` is the synonym for the current PC address.
      55/   0 :                         
      56/   0 :                         
      57/   0 :                                 INCLUDE "bitfuncs.inc"
(1)    1/   0 : =>UNDEFINED             		ifndef   bitfuncsinc    ; avoid multiple inclusion
(1)    2/   0 : =1H                     bitfuncsinc     equ      1
(1)    3/   0 :                         
 AS V1.42 Beta [Bld 281] - Source File sieve.asm(bitfuncs.inc) - Page 2 - 19/03/25 16:29:15


(1)    4/   0 :                                         save
(1)   77/   0 : ALL                                     restore                 ; allow listing again
(1)   78/   0 :                         
(1)   79/   0 : [1]                                     endif			; bitfuncsinc
(1)   80/   0 :                         
(1)   81/   0 :                         
      58/   0 :                         
      59/   0 :                         
      60/   0 :                         ; register aliases ------------------------------------------------------------
      61/   0 : =0H                     R0      EQU     0
      62/   0 : =1H                     R1      EQU     1
      63/   0 : =2H                     R2      EQU     2
      64/   0 : =3H                     R3      EQU     3
      65/   0 : =4H                     R4      EQU     4
      66/   0 : =5H                     R5      EQU     5
      67/   0 : =6H                     R6      EQU     6
      68/   0 : =7H                     R7      EQU     7
      69/   0 : =8H                     R8      EQU     8
      70/   0 : =9H                     R9      EQU     9
      71/   0 : =0AH                    RA      EQU     10
      72/   0 : =0BH                    RB      EQU     11
      73/   0 : =0CH                    RC      EQU     12
      74/   0 : =0DH                    RD      EQU     13
      75/   0 : =0EH                    RE      EQU     14
      76/   0 : =0FH                    RF      EQU     15
      77/   0 :                         
      78/   0 :                         
      79/   0 :                         ; -----------------------------------------------------------------------------
      80/   0 :                         ; PROGRAM
      81/   0 :                         ; -----------------------------------------------------------------------------
      82/   0 :                                 ORG     0
      83/   0 :                         code:
      84/   0 :                         
      85/   0 :                         	; ---------------------------------------------------------------------
      86/   0 :                         	; Initialize the program
      87/   0 :                         	; ---------------------------------------------------------------------
      88/   0 :                         	; When started after the reset, or by executing the monitor R0000 command:
      89/   0 :                         	; R0 is set to be both the program counter and the stack pointer
      90/   0 :                         	; R1 will become a program counter in the case of an interrupt
      91/   0 :                         	; R2 will become a stack pointer in the case of an interrupt
      92/   0 :                         	; The following section configures the registers:
      93/   0 :                         	; R2 points to the area that will become a stack pointer when control is passed to the main function
      94/   0 :                         	; R3 will become a program counter and point to the main function
      95/   0 :                         	; R4 will point to SCRT call routine
      96/   0 :                         	; R5 will point to SCRT return routine
      97/   0 :                         	; R6 will point to SCRT stack
      98/   0 :                         	; ---------------------------------------------------------------------
      99/   0 :                         
     100/   0 :                         	; Initialize R4 to 0x8ADB and R5 to 0x8AED to enable SCRT.
     101/   0 : F8 8A                   	LDI	hi(mon_scrt_call)
     102/   2 : B4                      	PHI	R4
     103/   3 : B5                      	PHI	R5
     104/   4 : F8 DB                   	LDI	lo(mon_scrt_call)
     105/   6 : A4                      	PLO	R4
     106/   7 : F8 ED                   	LDI	lo(mon_scrt_return)
     107/   9 : A5                      	PLO	R5
     108/   A :                         
     109/   A :                         	; Initialize R6 to SCRT_stack.
     110/   A : F8 04                   	LDI	hi(scrt_stack)
     111/   C : B6                      	PHI	R6
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 3 - 19/03/25 16:29:15


     112/   D : F8 7F                   	LDI	lo(scrt_stack)
     113/   F : A6                      	PLO	R6
     114/  10 :                         
     115/  10 :                         	; Configure R3 to point to the main function.
     116/  10 : F8 21                   	LDI	lo(main)
     117/  12 : A3                      	PLO	R3
     118/  13 : 90                      	GHI	R0
     119/  14 : B3                      	PHI	R3
     120/  15 :                         
     121/  15 :                         	; Configure R2 to point to the stack.
     122/  15 : F8 04                   	LDI	hi(stack)
     123/  17 : B2                      	PHI	R2
     124/  18 : F8 FF                   	LDI	lo(stack)
     125/  1A : A2                      	PLO	R2
     126/  1B :                         
     127/  1B :                         	; Pass the control to the main function.
     128/  1B : E2                      	SEX	R2			; Make R2 the default index register, i.e., the stack pointer.
     129/  1C : D3                      	SEP	R3			; Call the main function.
     130/  1D :                         
     131/  1D :                         	; ---------------------------------------------------------------------
     132/  1D :                         	; The program exit point.
     133/  1D :                         	; ---------------------------------------------------------------------
     134/  1D :                         	; R0 points to this location, so when SEP 0 is executed at the end of the main,
     135/  1D :                         	; the program execution will resume from this point.
     136/  1D : E0                      	SEX	R0			; R0 is now the default index register, similar to what it was after the reset.
     137/  1E : C0 80 00                	LBR	monitor			; Jump to the monitor.
     138/  21 :                         
     139/  21 :                         	; ---------------------------------------------------------------------
     140/  21 :                         	; The main function.
     141/  21 :                         	; ---------------------------------------------------------------------
     142/  21 :                         main:
     143/  21 : F8 03                   	LDI	hi(initial_msg)
     144/  23 : B7                      	PHI	R7
     145/  24 : F8 18                   	LDI	lo(initial_msg)
     146/  26 : A7                      	PLO	R7
     147/  27 : D4                      	SEP	R4
     148/  28 : 85                      	DB	hi(mon_put_str)
     149/  29 : 26                      	DB	lo(mon_put_str)
     150/  2A :                         
     151/  2A :                         	; ---------------------------------------------------------------------
     152/  2A :                         	; Initialize the `sieve` array for the initial case that 2 is the prime.
     153/  2A :                         	; R8 is the index within the sieve.
     154/  2A :                         	; RC is the counter.
     155/  2A :                         	; ---------------------------------------------------------------------
     156/  2A : F8 3F                   	LDI	hi(sieve_end-1)		; R8 points to the last element of the `sieve` array
     157/  2C : B8                      	PHI	R8
     158/  2D : F8 FF                   	LDI	lo(sieve_end-1)
     159/  2F : A8                      	PLO	R8
     160/  30 : F8 00                   	LDI	0
     161/  32 : AC                      	PLO	RC
     162/  33 :                         
     163/  33 : E8                      	SEX	R8			; Use R8 as the index register; R8 points to the `sieve`.
     164/  34 :                         
     165/  34 :                         init_loop:
     166/  34 : F8 55                   	LDI	0b01010101		; Prepopulate the sieve to a state corresponding to 2 being a prime.
     167/  36 :                         	REPT	32			; Unwind the loop so only the `RC.LO` register is used as a counter (32 * 256 == 8k)
     168/  36 :                         	STXD
     169/  36 :                         	ENDM
     168/  36 : 73                      	STXD
     168/  37 : 73                      	STXD
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 4 - 19/03/25 16:29:15


     168/  38 : 73                      	STXD
     168/  39 : 73                      	STXD
     168/  3A : 73                      	STXD
     168/  3B : 73                      	STXD
     168/  3C : 73                      	STXD
     168/  3D : 73                      	STXD
     168/  3E : 73                      	STXD
     168/  3F : 73                      	STXD
     168/  40 : 73                      	STXD
     168/  41 : 73                      	STXD
     168/  42 : 73                      	STXD
     168/  43 : 73                      	STXD
     168/  44 : 73                      	STXD
     168/  45 : 73                      	STXD
     168/  46 : 73                      	STXD
     168/  47 : 73                      	STXD
     168/  48 : 73                      	STXD
     168/  49 : 73                      	STXD
     168/  4A : 73                      	STXD
     168/  4B : 73                      	STXD
     168/  4C : 73                      	STXD
     168/  4D : 73                      	STXD
     168/  4E : 73                      	STXD
     168/  4F : 73                      	STXD
     168/  50 : 73                      	STXD
     168/  51 : 73                      	STXD
     168/  52 : 73                      	STXD
     168/  53 : 73                      	STXD
     168/  54 : 73                      	STXD
     168/  55 : 73                      	STXD
     170/  56 : 2C                      	DEC	RC
     171/  57 : 8C                      	GLO	RC
     172/  58 : 3A 34                   	BNZ	init_loop
     173/  5A :                         
     174/  5A :                         	; This is the special case for the very first byte; 1 is neither prime nor composite,
     175/  5A :                         	; and 2 is the only even prime.
     176/  5A :                         	; Note: R8 points to a byte just below the start of the sieve.
     177/  5A : 18                      	INC	R8			; Point R8 to the 1st element.
     178/  5B : F8 95                   	LDI	0b10010101		; The 1st byte must account for 2 being a prime and 1 not.
     179/  5D : 58                      	STR	R8
     180/  5E :                         
     181/  5E : E2                      	SEX	R2			; Restore default index register.
     182/  5F :                         
     183/  5F :                         	; ---------------------------------------------------------------------
     184/  5F :                         	; Detect primes other primes starting with 3:
     185/  5F :                         	; 1. loop over all odd numbers less than 32768
     186/  5F :                         	;   2. if the current testing number is not marked yet, it is a prime
     187/  5F :                         	;      3.1 set the marking step to be twice the current prime
     188/  5F :                         	;      3.2 starting from the current prime, using the marking step as the
     189/  5F :                         	;          increment, mark every encountered number as a composite.
     190/  5F :                         	; RC holds the current number being tested (step 1)
     191/  5F :                         	; RA holds the pointer to`tmp_mark`, which holds the current number being
     192/  5F :                         	;     marked as composite (step 3.2)
     193/  5F :                         	; RD holds the pointer to the `step` in which RA is incremented (step 3.2)
     194/  5F :                         	; R8, R9.LO are used to update the context of `sieve` (step 3.2)
     195/  5F :                         	;     R8 points to the byte, and R9.LO is the bit mask to test/update
     196/  5F :                         	; ---------------------------------------------------------------------
     197/  5F :                         
     198/  5F :                         	; initialize the RC, RA and RD
     199/  5F : F8 00                   	LDI	0			; RC is 0003
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 5 - 19/03/25 16:29:15


     200/  61 : BC                      	PHI	RC
     201/  62 : F8 03                   	LDI	3
     202/  64 : AC                      	PLO	RC
     203/  65 : F8 03                   	LDI	hi(vars)		; RA points to `tmp_mark`
     204/  67 : BA                      	PHI	RA
     205/  68 : BD                      	PHI	RD
     206/  69 : F8 09                   	LDI	lo(tmp_mark)
     207/  6B : AA                      	PLO	RA
     208/  6C : F8 0B                   	LDI	lo(step)		; RD points to `step`
     209/  6E : AD                      	PLO	RD
     210/  6F :                         
     211/  6F :                         	; ---------------------------------------------------------------------
     212/  6F :                         	; The outer loop loops over all odd numbers starting with 3 less than 256.
     213/  6F :                         	; Note: looping over the first sqrt(N) prime candidates is enough to sieve out
     214/  6F :                         	; all composites up to N.
     215/  6F :                         	; If any encountered number has not already been marked, it is a prime,
     216/  6F :                         	; and we must sieve out all its multiples starting with the square of this number.
     217/  6F :                         	; ---------------------------------------------------------------------
     218/  6F :                         
     219/  6F :                         outer_marking_loop:
     220/  6F :                         	; Initialize the current testing number in `tmp_mark` and `step` using value from RC.
     221/  6F : 9C                      	GHI	RC			; get RC.HI
     222/  70 : 5A                      	STR	RA			; store it to the 1st byte of `tmp_mark`
     223/  71 : 5D                      	STR	RD			; and to the 1st byte of `step`
     224/  72 : 1A                      	INC	RA			; move RA to the 2nd byte of `tmp_mark`
     225/  73 : 1D                      	INC	RD			; move RD to the 2nd byte of `step`
     226/  74 : 8C                      	GLO	RC			; get the RC.LO
     227/  75 : 5A                      	STR	RA			; and store it to the 2nd byte of `tmp_mark`
     228/  76 :                         	; double it for the step value
     229/  76 : FE                      	SHL				; double the value in D, MSB carry overflows to DF
     230/  77 : 5D                      	STR	RD			; store it as the 2nd byte of `step`
     231/  78 : 2D                      	DEC	RD			; then point RD to the 1st byte of `step`
     232/  79 : 0D                      	LDN	RD			; and load the 1st byte of `step`.
     233/  7A : 7E                      	SHLC				; Double it and populate the LSB from DF.
     234/  7B : 5D                      	STR	RD			; Store the result to the 1st byte of `step`
     235/  7C :                         	; At this moment, RD points to the 1st byte of `step`.
     236/  7C : 2A                      	DEC	RA			; RA points to the 1st byte of `tmp_mark`.
     237/  7D :                         
     238/  7D :                         	; ---------------------------------------------------------------------
     239/  7D :                         	; Check if the number has already been marked. If so, skip it and continue
     240/  7D :                         	; with the next candidate.
     241/  7D :                         	; ---------------------------------------------------------------------
     242/  7D :                         
     243/  7D :                         	; Put the byte index of the number from `tmp_mark` into R8.
     244/  7D :                         	; Note that the number 1 in `tmp_mark` is represented by the bit 0 of the byte 0 of `sieve`.
     245/  7D : 4A                      	LDA	RA			; Read the value pointed by RA
     246/  7E : B8                      	PHI	R8			; and copy it to R8.
     247/  7F : 0A                      	LDN	RA
     248/  80 : A8                      	PLO	R8
     249/  81 : 28                      	DEC	R8			; Fix the offset error between the prime representation in RC and the one in `sieve`.
     250/  82 :                         	; Let R9 point to `mark_mask`. Note the optimization if it is placed on the page boundary.
     251/  82 : F8 03                   	LDI	hi(mark_mask)
     252/  84 : B9                      	PHI	R9
     253/  85 : F8 00                   	LDI	0
     254/  87 : A9                      	PLO	R9
     255/  88 : 2A                      	DEC	RA			; Keep RA pointing to the first byte of `tmp_mark`.
     256/  89 :                         
     257/  89 :                         	; Shift R8 3 times to the right. The shifted-out bits are shifted into R9.LO.
     258/  89 :                         	REPT	3
     259/  89 :                         	GHI	R8
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 6 - 19/03/25 16:29:15


     260/  89 :                         	SHR
     261/  89 :                         	PHI	R8
     262/  89 :                         	GLO	R8
     263/  89 :                         	SHRC
     264/  89 :                         	PLO	R8
     265/  89 :                         	GLO	R9
     266/  89 :                         	SHRC
     267/  89 :                         	PLO	R9
     268/  89 :                         	ENDM
     259/  89 : 98                      	GHI	R8
     260/  8A : F6                      	SHR
     261/  8B : B8                      	PHI	R8
     262/  8C : 88                      	GLO	R8
     263/  8D : 76                      	SHRC
     264/  8E : A8                      	PLO	R8
     265/  8F : 89                      	GLO	R9
     266/  90 : 76                      	SHRC
     267/  91 : A9                      	PLO	R9
     259/  92 : 98                      	GHI	R8
     260/  93 : F6                      	SHR
     261/  94 : B8                      	PHI	R8
     262/  95 : 88                      	GLO	R8
     263/  96 : 76                      	SHRC
     264/  97 : A8                      	PLO	R8
     265/  98 : 89                      	GLO	R9
     266/  99 : 76                      	SHRC
     267/  9A : A9                      	PLO	R9
     259/  9B : 98                      	GHI	R8
     260/  9C : F6                      	SHR
     261/  9D : B8                      	PHI	R8
     262/  9E : 88                      	GLO	R8
     263/  9F : 76                      	SHRC
     264/  A0 : A8                      	PLO	R8
     265/  A1 : 89                      	GLO	R9
     266/  A2 : 76                      	SHRC
     267/  A3 : A9                      	PLO	R9
     269/  A4 :                         	; Right align R9.LO.
     270/  A4 :                         	REPT	5
     271/  A4 :                         	SHR
     272/  A4 :                         	ENDM
     271/  A4 : F6                      	SHR
     271/  A5 : F6                      	SHR
     271/  A6 : F6                      	SHR
     271/  A7 : F6                      	SHR
     271/  A8 : F6                      	SHR
     273/  A9 : A9                      	PLO	R9
     274/  AA :                         
     275/  AA :                         	; Make R8 point to the correct byte within `sieve`.
     276/  AA : 98                      	GHI	R8
     277/  AB : FC 20                   	ADI	hi(sieve)
     278/  AD : B8                      	PHI	R8
     279/  AE :                         	; There is no need to add the lower part of the `mark_mask` address to R9.LO if it is on the page boundary.
     280/  AE :                         
     281/  AE :                         	; Test the bit based on the mask pointed by R9. If it is already marked, look for another candidate.
     282/  AE : 08                      	LDN	R8
     283/  AF : E9                      	SEX	R9
     284/  B0 : F2                      	AND
     285/  B1 : E2                      	SEX	R2
     286/  B2 : CA 01 1F                	LBNZ	next_marking_number
     287/  B5 :                         
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 7 - 19/03/25 16:29:15


     288/  B5 :                         	; ---------------------------------------------------------------------
     289/  B5 :                         	; At this point, we have a prime number.
     290/  B5 :                         	; The square of that number is the first unmarked composite in a sequence of
     291/  B5 :                         	; composites that will be mask based on this prime number by the inner loop.
     292/  B5 :                         	; The square is calculated by multiplying the value in RC with itself.
     293/  B5 :                         	; The result is held in `tmp_mark`.
     294/  B5 :                         	; RA is pointer to `tmp_mark`.
     295/  B5 :                         	; R8 is a temporary register where the 2nd multiplicand is held.
     296/  B5 :                         	; ---------------------------------------------------------------------
     297/  B5 :                         	; Note: RA currently point to the 1st byte of `tmp_mark`
     298/  B5 : 8C                      	GLO	RC			; preserve the RC.LO
     299/  B6 : 73                      	STXD
     300/  B7 : 9C                      	GHI	RC			; RC.HI is 0
     301/  B8 : 5A                      	STR	RA			; set 0 to the 1st byte of `tmp_mark`
     302/  B9 : 1A                      	INC	RA
     303/  BA : 5A                      	STR	RA			; set 0 to the 2nd byte of `tmp_mark`
     304/  BB : B8                      	PHI	R8			; R8 holds 2nd multiplication operant. R8.HI is 0
     305/  BC : 8C                      	GLO	RC			; the R8.LO is initially the prime
     306/  BD : A8                      	PLO	R8
     307/  BE : EA                      	SEX	RA			; RA is index
     308/  BF :                         	; The squaring operation loop
     309/  BF :                         sq_loop:
     310/  BF :                         	; RA points to the 2nd byte of `tmp_mask`
     311/  BF :                         	; test if MSB of RC is 1 or 0
     312/  BF : 8C                      	GLO	RC			; check if RC is shifted out
     313/  C0 : 32 D5                   	BZ	square_res		; if RC is 0, squaring operation is completed
     314/  C2 : F6                      	SHR				; otherwise, shift out the LSB of RC
     315/  C3 : AC                      	PLO	RC			; store the new value of RC
     316/  C4 : 3B CD                   	BNF	sq_after_sum		; if the shifted out bit was 0, skip the partial sum
     317/  C6 :                         	; shifted out bit was 1, do the partial sum, note RA points to the 2nd byte of `tmp_mark`
     318/  C6 : 88                      	GLO	R8			; get low part of the 2nd multiplication operand
     319/  C7 : F4                      	ADD				; add it with the 2nd byte of the partial sum in `tmp_mark`
     320/  C8 : 73                      	STXD				; store the result in the 2nd byte of `tmp_mark` and move RA to the 1st byte
     321/  C9 : 98                      	GHI	R8			; get the hi part of the 2nd multiplication operand
     322/  CA : 74                      	ADC				; add the 1st byte of the partial sum with carry
     323/  CB : 5A                      	STR	RA			; store the result in the 1st byte of `tmp_mark`
     324/  CC : 1A                      	INC	RA			; let RA point to the 2nd byte of `tmp_mark`
     325/  CD :                         sq_after_sum:
     326/  CD :                         	; shift left the 2nd multiplication operand
     327/  CD : 88                      	GLO	R8
     328/  CE : FE                      	SHL
     329/  CF : A8                      	PLO	R8
     330/  D0 : 98                      	GHI	R8
     331/  D1 : 7E                      	SHLC
     332/  D2 : B8                      	PHI	R8
     333/  D3 : 30 BF                   	BR	sq_loop
     334/  D5 :                         square_res:
     335/  D5 : E2                      	SEX	R2			; restore the default index register
     336/  D6 : 60                      	IRX				; restore RC.LO
     337/  D7 : F0                      	LDX
     338/  D8 : AC                      	PLO	RC
     339/  D9 : 2A                      	DEC	RA			; let RA point to the 1st byte of `tmp_mark`
     340/  DA :                         
     341/  DA :                         	; ---------------------------------------------------------------------
     342/  DA :                         	; The inner loop marks all multiples of the prime as composite numbers.
     343/  DA :                         	; ---------------------------------------------------------------------
     344/  DA :                         
     345/  DA :                         inner_marking_loop:
     346/  DA :                         
     347/  DA :                         	; RA points to the 1st byte of `tmp_mark`.
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 8 - 19/03/25 16:29:15


     348/  DA :                         
     349/  DA :                         	; ---------------------------------------------------------------------
     350/  DA :                         	; Mark the composite number.
     351/  DA :                         	; ---------------------------------------------------------------------
     352/  DA :                         
     353/  DA :                         	; Put the byte index of the number from `tmp_mark` into R8.
     354/  DA :                         	; Note that the number 1 in `tmp_mark` is represented by the bit 0 of the byte 0 of `sieve`.
     355/  DA : 4A                      	LDA	RA			; Read the value pointed by RA
     356/  DB : B8                      	PHI	R8			; and copy it to R8.
     357/  DC : 0A                      	LDN	RA
     358/  DD : A8                      	PLO	R8
     359/  DE : 28                      	DEC	R8			; Fix the offset error between the prime representation in RC and the one in `sieve`.
     360/  DF :                         	; Let R9 point to `mark_mask`. Note the optimization if it is placed on the page boundary.
     361/  DF : F8 03                   	LDI	hi(mark_mask)
     362/  E1 : B9                      	PHI	R9
     363/  E2 : F8 00                   	LDI	0
     364/  E4 : A9                      	PLO	R9
     365/  E5 : 2A                      	DEC	RA			; Keep RA pointing to the first byte of `tmp_mark`.
     366/  E6 :                         
     367/  E6 :                         	; Shift R8 3 times to the right. The shifted-out bits are shifted into R9.LO.
     368/  E6 :                         	REPT	3
     369/  E6 :                         	GHI	R8
     370/  E6 :                         	SHR
     371/  E6 :                         	PHI	R8
     372/  E6 :                         	GLO	R8
     373/  E6 :                         	SHRC
     374/  E6 :                         	PLO	R8
     375/  E6 :                         	GLO	R9
     376/  E6 :                         	SHRC
     377/  E6 :                         	PLO	R9
     378/  E6 :                         	ENDM
     369/  E6 : 98                      	GHI	R8
     370/  E7 : F6                      	SHR
     371/  E8 : B8                      	PHI	R8
     372/  E9 : 88                      	GLO	R8
     373/  EA : 76                      	SHRC
     374/  EB : A8                      	PLO	R8
     375/  EC : 89                      	GLO	R9
     376/  ED : 76                      	SHRC
     377/  EE : A9                      	PLO	R9
     369/  EF : 98                      	GHI	R8
     370/  F0 : F6                      	SHR
     371/  F1 : B8                      	PHI	R8
     372/  F2 : 88                      	GLO	R8
     373/  F3 : 76                      	SHRC
     374/  F4 : A8                      	PLO	R8
     375/  F5 : 89                      	GLO	R9
     376/  F6 : 76                      	SHRC
     377/  F7 : A9                      	PLO	R9
     369/  F8 : 98                      	GHI	R8
     370/  F9 : F6                      	SHR
     371/  FA : B8                      	PHI	R8
     372/  FB : 88                      	GLO	R8
     373/  FC : 76                      	SHRC
     374/  FD : A8                      	PLO	R8
     375/  FE : 89                      	GLO	R9
     376/  FF : 76                      	SHRC
     377/ 100 : A9                      	PLO	R9
     379/ 101 :                         	; Right align R9.LO.
     380/ 101 :                         	REPT	5
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 9 - 19/03/25 16:29:15


     381/ 101 :                         	SHR
     382/ 101 :                         	ENDM
     381/ 101 : F6                      	SHR
     381/ 102 : F6                      	SHR
     381/ 103 : F6                      	SHR
     381/ 104 : F6                      	SHR
     381/ 105 : F6                      	SHR
     383/ 106 : A9                      	PLO	R9
     384/ 107 :                         
     385/ 107 :                         	; Make R8 point to the correct byte within `sieve`.
     386/ 107 : 98                      	GHI	R8
     387/ 108 : FC 20                   	ADI	hi(sieve)
     388/ 10A : B8                      	PHI	R8
     389/ 10B :                         	; There is no need to add the lower part of the `mark_mask` address to R9.LO if it is on the page boundary.
     390/ 10B :                         
     391/ 10B :                         	; Set the bit to indicate that it corresponds to the composite number.
     392/ 10B : 08                      	LDN	R8
     393/ 10C : E9                      	SEX	R9
     394/ 10D : F1                      	OR
     395/ 10E : E2                      	SEX	R2
     396/ 10F : 58                      	STR	R8
     397/ 110 :                         
     398/ 110 :                         	; ---------------------------------------------------------------------
     399/ 110 :                         	; Calculate the next numbers to mark: M[RA] = M[RA] + M[RD]
     400/ 110 :                         	; ---------------------------------------------------------------------
     401/ 110 :                         
     402/ 110 :                         	; RA points th the 1st byte of `tmp_mark`, and RD points to the 1st byte of `step`.
     403/ 110 : ED                      	SEX	RD			; make RD index
     404/ 111 : 1D                      	INC	RD			; let RD point to the 2nd byte of `step`
     405/ 112 : 1A                      	INC	RA			; let RA point to the 2nd byte of `tnp_mark`
     406/ 113 : 0A                      	LDN	RA			; load the 2nd byte of `tmp_mark`
     407/ 114 : F4                      	ADD				; add the 2nd byte of `step`
     408/ 115 : 5A                      	STR	RA			; store the result to the 2nd byte of `tmp_mark`
     409/ 116 : 2D                      	DEC	RD			; point to the 1st byte of `step`
     410/ 117 : 2A                      	DEC	RA			; point to the 1st byte of `tmp_mark`
     411/ 118 : 0A                      	LDN	RA			; load the 1st byte of `tmp_mark`
     412/ 119 : 74                      	ADC				; add the 1st byte of `step` with carry
     413/ 11A : 5A                      	STR	RA			; store the result to the 1st byte of `tmp_mark`
     414/ 11B : E2                      	SEX	R2			; restore the default index register
     415/ 11C :                         	; If M[RA] >= 65536, i.e., the carry has occurred, then the inner loop has been completed.
     416/ 11C : CB 00 DA                	LBNF	inner_marking_loop	; The carry is not detected, repeat the inner loop.
     417/ 11F :                         
     418/ 11F :                         next_marking_number:
     419/ 11F :                         
     420/ 11F :                         	; Increment RC twice, so it will hold the next odd number.
     421/ 11F : 1C                      	INC	RC
     422/ 120 : 1C                      	INC	RC
     423/ 121 :                         
     424/ 121 :                         	; It is enough to iterate only over sqrt(N) candidates to mark all composite numbers up to N.
     425/ 121 :                         	; In our case, N is 65537, so we need to iterate only over the first 256 candidates, i.e.,
     426/ 121 :                         	; when RC.HI stops being 0; we are done.
     427/ 121 : 9C                      	GHI	RC
     428/ 122 : C2 00 6F                	LBZ	outer_marking_loop
     429/ 125 :                         
     430/ 125 :                         
     431/ 125 :                         	; ---------------------------------------------------------------------
     432/ 125 :                         	; Print results
     433/ 125 :                         	; Don't assume any register is now in a usable state; reinitialize required registers:
     434/ 125 :                         	; The code iterates over the `sieve` and tests every bit to determine if the corresponding
     435/ 125 :                         	; number has been marked as a composite or a prime. If it is a prime, it is printed.
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 10 - 19/03/25 16:29:15


     436/ 125 :                         	; R8 is the index into the `sieve`,
     437/ 125 :                         	; R9 points to the `prt_mask`,
     438/ 125 :                         	; RC is the number to print,
     439/ 125 :                         	; RD.LO is used for tabulation. It holds a count of numbers printed in the current row.
     440/ 125 :                         	; ---------------------------------------------------------------------
     441/ 125 :                         print_result:
     442/ 125 :                         	; Print the message stating what is being printed.
     443/ 125 : F8 03                   	LDI	hi(print_start_msg)
     444/ 127 : B7                      	PHI	R7
     445/ 128 : F8 65                   	LDI	lo(print_start_msg)
     446/ 12A : A7                      	PLO	R7
     447/ 12B : D4                      	SEP	R4
     448/ 12C : 85                      	DB	hi(mon_put_str)
     449/ 12D : 26                      	DB	lo(mon_put_str)
     450/ 12E :                         
     451/ 12E :                          	; 1 is the first number to test; load it to RC.
     452/ 12E : F8 01                   	LDI	1
     453/ 130 : AC                      	PLO	RC
     454/ 131 : F8 00                   	LDI	0
     455/ 133 : BC                      	PHI	RC
     456/ 134 :                         
     457/ 134 :                         	; Load the address of the `sieve` to R8.
     458/ 134 : F8 20                   	LDI	hi(sieve)
     459/ 136 : B8                      	PHI	R8
     460/ 137 : F8 00                   	LDI	lo(sieve)
     461/ 139 : A8                      	PLO	R8
     462/ 13A :                         
     463/ 13A :                         	; Load the address of `prt_mask` to R9.
     464/ 13A : F8 03                   	LDI	hi(prt_mask)
     465/ 13C : B9                      	PHI	R9
     466/ 13D : F8 08                   	LDI	lo(prt_mask)
     467/ 13F : A9                      	PLO	R9
     468/ 140 :                         
     469/ 140 :                         	; Load 0 to RD to initialize tabulation.
     470/ 140 : 9C                      	GHI	RC			; RC.HI is currently 0
     471/ 141 : AD                      	PLO	RD
     472/ 142 :                         
     473/ 142 :                         print_res_loop:
     474/ 142 :                         	; Initialize `prt_mask` for a current bit in `sieve`.
     475/ 142 :                         	; It is required if we rerun the program without reloading it.
     476/ 142 : F8 80                   	LDI	0b10000000
     477/ 144 : 59                      	STR	R9
     478/ 145 :                         
     479/ 145 :                         print_res_mask_loop:
     480/ 145 :                         	; Is the masked-out bit set?
     481/ 145 : 09                      	LDN	R9			; Load `prt_mask` to D
     482/ 146 : E8                      	SEX	R8			; R8 is the index into `sieve`
     483/ 147 : F2                      	AND				; D = D & (*R8)
     484/ 148 : E2                      	SEX	R2			; restore the default index register
     485/ 149 : 3A 58                   	BNZ	prt_skip_not_prime	; if D is not zero, then we have a composite.
     486/ 14B :                         
     487/ 14B :                         	; D was 0, so it is a prime. Print the number held within RC.
     488/ 14B : D4                      	SEP	R4
     489/ 14C : 01                      	DB	hi(prt_16b_num)
     490/ 14D : 6E                      	DB	lo(prt_16b_num)
     491/ 14E :                         
     492/ 14E :                         	; Check if 10 numbers have been printed in this row.
     493/ 14E : 1D                      	INC	RD
     494/ 14F : 8D                      	GLO	RD
     495/ 150 : FF 0A                   	SMI	10
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 11 - 19/03/25 16:29:15


     496/ 152 : 3A 58                   	BNZ	prt_skip_not_prime	; no, skp printing <CR><NL>
     497/ 154 : AD                      	PLO	RD			; yes, reset the counter
     498/ 155 :                         
     499/ 155 :                         	; print <CR><LF>
     500/ 155 : D4                      	SEP	R4
     501/ 156 : 85                      	DB	hi(mon_crlf)
     502/ 157 : 19                      	DB	lo(mon_crlf)
     503/ 158 :                         
     504/ 158 :                         prt_skip_not_prime:
     505/ 158 :                         
     506/ 158 :                         	; Test the next number.
     507/ 158 : 1C                      	INC	RC			; Increment the register holding a number to print.
     508/ 159 :                         
     509/ 159 :                         	; Shift the `prt_mask`.
     510/ 159 : 09                      	LDN	R9			; load the `prt_mask` to D
     511/ 15A : F6                      	SHR				; shift the value in `prt_mask` 1 bit to the right,
     512/ 15B : 59                      	STR	R9			; store the updated value of `prt_mask`
     513/ 15C : 3A 45                   	BNZ	print_res_mask_loop	; `prt_mask` is not zero; continue with the same byte within the `sieve`
     514/ 15E : 18                      	INC	R8			; otherwise, point to the next byte in the `sieve` array
     515/ 15F :                         
     516/ 15F :                         	; If all numbers are tested, R8 will point to `sieve_end`.
     517/ 15F : 98                      	GHI	R8			; get R8.HI
     518/ 160 : FF 40                   	SMI	hi(sieve_end)		; subtract the high part of `sieve_end`
     519/ 162 : 3A 42                   	BNZ	print_res_loop
     520/ 164 :                         
     521/ 164 :                         print_loop_end:
     522/ 164 :                         
     523/ 164 :                         	; Print the final message and return to the monitor.
     524/ 164 : F8 03                   	LDI	hi(final_msg)
     525/ 166 : B7                      	PHI	R7
     526/ 167 : F8 87                   	LDI	lo(final_msg)
     527/ 169 : A7                      	PLO	R7
     528/ 16A : D4                      	SEP	R4
     529/ 16B : 85                      	DB	hi(mon_put_str)
     530/ 16C : 26                      	DB	lo(mon_put_str)
     531/ 16D :                         
     532/ 16D :                         	; ---------------------------------------------------------------------
     533/ 16D :                         	; Exit main function: return the control to the program exit point.
     534/ 16D :                         	; ---------------------------------------------------------------------
     535/ 16D : D0                      	SEP	R0
     536/ 16E :                         
     537/ 16E :                         
     538/ 16E :                         prt_16b_num:
     539/ 16E :                         	; ---------------------------------------------------------------------
     540/ 16E :                         	; Print a 16-bit number provided in RC.
     541/ 16E :                         	; R7 is used as a pointer to a string holding a converted number.
     542/ 16E :                         	; RC holds the 16-bit value to be converted.
     543/ 16E :                         	; RA, RC and RD are scratch-pad registers for a digit conversion.
     544/ 16E :                         	; All registers except D and DF are preserved.
     545/ 16E :                         	; ---------------------------------------------------------------------
     546/ 16E :                         	; Preserve R7, R8, RA, RC, and RD registers.
     547/ 16E : 97                      	GHI	R7			; use as a pointer to a string to print
     548/ 16F : 73                      	STXD
     549/ 170 : 87                      	GLO	R7
     550/ 171 : 73                      	STXD
     551/ 172 : 98                      	GHI	R8
     552/ 173 : 73                      	STXD
     553/ 174 : 88                      	GLO	R8
     554/ 175 : 73                      	STXD
     555/ 176 : 9A                      	GHI	RA			; scratch-pad register for number conversion
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 12 - 19/03/25 16:29:15


     556/ 177 : 73                      	STXD
     557/ 178 : 8A                      	GLO	RA
     558/ 179 : 73                      	STXD
     559/ 17A : 9C                      	GHI	RC			; holds the 16-bit value to convert
     560/ 17B : 73                      	STXD
     561/ 17C : 8C                      	GLO	RC
     562/ 17D : 73                      	STXD
     563/ 17E : 9D                      	GHI	RD			; scratch-pad register for number conversion
     564/ 17F : 73                      	STXD
     565/ 180 : 8D                      	GLO	RD
     566/ 181 : 73                      	STXD
     567/ 182 :                         
     568/ 182 :                         	; Copy the value pointed to by the provided immediate address to `tmp_conv`.
     569/ 182 :                         	; Note: `tmp_conv` is 1 byte longer than the number to print.
     570/ 182 :                         	; Its 1st byte is initialized to 0 (it will hold the division remainder).
     571/ 182 :                         	; Use RC as the source value and RD as the destination index.
     572/ 182 : 99                      	GHI	R9			; RA.HI, RC.HI, and RD.HI are the same as R9.HI (`vars:` page address)
     573/ 183 : BA                      	PHI	RA			; initialize the high part of RA - needed later in the `dec_digit` function
     574/ 184 : BD                      	PHI	RD			; initialize the high part of RD
     575/ 185 : F8 0D                   	LDI	lo(tmp_conv)		; load the low part of the `tmp_conv` address
     576/ 187 : AD                      	PLO	RD			; put it in the low part of RD to make RD point to the destination buffer
     577/ 188 : F8 00                   	LDI	0			; set 0 to the first byte of `tmp_conv`
     578/ 18A : 5D                      	STR	RD
     579/ 18B : 1D                      	INC	RD			; increase RD to point to the 2nd byte of `tmp_conv`
     580/ 18C : 9C                      	GHI	RC			; copy the 1st byte of the value pointed by RC to the location pointed by RD
     581/ 18D : 5D                      	STR	RD
     582/ 18E : 1D                      	INC	RD			; increase RD to point to the 3rd byte of `tmp_conv`
     583/ 18F : 8C                      	GLO	RC			; copy the 2nd byte of the value pointed by RC to the location pointed by RD
     584/ 190 : 5D                      	STR	RD
     585/ 191 :                         
     586/ 191 :                         	; Initialize the string buffer where the decimal conversion result will be written
     587/ 191 :                         	; to the default result as if the conversion input was 0.
     588/ 191 : F8 03                   	LDI	hi(vars)
     589/ 193 : BC                      	PHI	RC
     590/ 194 : F8 17                   	LDI	lo(prt_buf_end-1)	; the low part points to the end of the print buffer
     591/ 196 : AC                      	PLO	RC
     592/ 197 : EC                      	SEX	RC			; temporary set RC to act as the index register
     593/ 198 : F8 00                   	LDI	0			; the trailing '\0'
     594/ 19A : 73                      	STXD
     595/ 19B : F8 30                   	LDI	'0'			; the corner case for 0, to be overwritten if the input number is not 0
     596/ 19D : 73                      	STXD
     597/ 19E : F8 20                   	LDI	0x20			; fill the rest of the buffer with ' '
     598/ 1A0 :                         	REPT	5			; an inline macro that repeats commands till ENDM 5 times
     599/ 1A0 :                         	STXD
     600/ 1A0 :                         	ENDM
     599/ 1A0 : 73                      	STXD
     599/ 1A1 : 73                      	STXD
     599/ 1A2 : 73                      	STXD
     599/ 1A3 : 73                      	STXD
     599/ 1A4 : 73                      	STXD
     601/ 1A5 : E2                      	SEX	R2			; restore the default index register
     602/ 1A6 :                         
     603/ 1A6 :                         	; Let RC point to the last position of `prt_buf`.
     604/ 1A6 : F8 17                   	LDI	lo(prt_buf_end-1)
     605/ 1A8 : AC                      	PLO	RC
     606/ 1A9 :                         
     607/ 1A9 :                         	; Convert the 16-bit unsigned value pointed by RA to a decimal string.
     608/ 1A9 :                         	; We have at most 5 decimal digits, repeat digit conversion 5 times starting from the rightmost position.
     609/ 1A9 :                         	REPT	5			; an inline macro that repeats commands till ENDM 5 times
     610/ 1A9 :                         	SEP	R4			; convert a single digit
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 13 - 19/03/25 16:29:15


     611/ 1A9 :                         	DB	hi(dec_digit)
     612/ 1A9 :                         	DB	lo(dec_digit)
     613/ 1A9 :                         	ENDM
     610/ 1A9 : D4                      	SEP	R4			; convert a single digit
     611/ 1AA : 02                      	DB	hi(dec_digit)
     612/ 1AB : 00                      	DB	lo(dec_digit)
     610/ 1AC : D4                      	SEP	R4			; convert a single digit
     611/ 1AD : 02                      	DB	hi(dec_digit)
     612/ 1AE : 00                      	DB	lo(dec_digit)
     610/ 1AF : D4                      	SEP	R4			; convert a single digit
     611/ 1B0 : 02                      	DB	hi(dec_digit)
     612/ 1B1 : 00                      	DB	lo(dec_digit)
     610/ 1B2 : D4                      	SEP	R4			; convert a single digit
     611/ 1B3 : 02                      	DB	hi(dec_digit)
     612/ 1B4 : 00                      	DB	lo(dec_digit)
     610/ 1B5 : D4                      	SEP	R4			; convert a single digit
     611/ 1B6 : 02                      	DB	hi(dec_digit)
     612/ 1B7 : 00                      	DB	lo(dec_digit)
     614/ 1B8 :                         
     615/ 1B8 :                         	; Print the string with the conversion result. R7 is a pointer to the null-terminated string.
     616/ 1B8 : F8 03                   	LDI	hi(prt_buf)
     617/ 1BA : B7                      	PHI	R7
     618/ 1BB : F8 11                   	LDI	lo(prt_buf)
     619/ 1BD : A7                      	PLO	R7
     620/ 1BE : D4                      	SEP	R4
     621/ 1BF : 85                      	DB	hi(mon_put_str)
     622/ 1C0 : 26                      	DB	lo(mon_put_str)
     623/ 1C1 :                         
     624/ 1C1 :                         	; Restore R7, R8, RA, RC, and RD registers.
     625/ 1C1 : 60                      	IRX
     626/ 1C2 : 72                      	LDXA				; restore RD
     627/ 1C3 : AD                      	PLO	RD
     628/ 1C4 : 72                      	LDXA
     629/ 1C5 : BD                      	PHI	RD
     630/ 1C6 : 72                      	LDXA				; restore RC
     631/ 1C7 : AC                      	PLO	RC
     632/ 1C8 : 72                      	LDXA
     633/ 1C9 : BC                      	PHI	RC
     634/ 1CA : 72                      	LDXA				; restore RA
     635/ 1CB : AA                      	PLO	RA
     636/ 1CC : 72                      	LDXA
     637/ 1CD : BA                      	PHI	RA
     638/ 1CE : 72                      	LDXA				; restore R8
     639/ 1CF : A8                      	PLO	R8
     640/ 1D0 : 72                      	LDXA
     641/ 1D1 : B8                      	PHI	R8
     642/ 1D2 : 72                      	LDXA				; restore R7
     643/ 1D3 : A7                      	PLO	R7
     644/ 1D4 : F0                      	LDX
     645/ 1D5 : B7                      	PHI	R7
     646/ 1D6 :                         	; return
     647/ 1D6 : D5                      	SEP	R5
     648/ 1D7 :                         
     649/ 1D7 :                         
     650/ 200 :                         	ORG	(code+0x0200)
     651/ 200 :                         dec_digit:
     652/ 200 :                         	; ---------------------------------------------------------------------
     653/ 200 :                         	; This function converts the single decimal digit by dividing the number
     654/ 200 :                         	; in `tmp_conv` by the number in `radix` and writes the result
     655/ 200 :                         	; to the correct position in `prt_buf`. It is intended to be called
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 14 - 19/03/25 16:29:15


     656/ 200 :                         	; as many times as necessary to convert the whole number.
     657/ 200 :                         	; `tmp_conv` is 3 bytes long, the 1st byte is 0 on input, while the 2nd
     658/ 200 :                         	; and the 3rd byte hold the number to be converted.
     659/ 200 :                         	; As per RCA 1802 convention, the big-endian notation is used.
     660/ 200 :                         	; If the number in `tmp_conv` is 0, the function returns immediately;
     661/ 200 :                                 ; otherwise, it divides that number by a radix value.
     662/ 200 :                         	; The division is performed in place, the result replaces the dividend,
     663/ 200 :                         	; and the remainder is held in the 1st byte of the `tmp_conv` buffer.
     664/ 200 :                         	; The remainder is converted to a character and written in the memory
     665/ 200 :                         	; location pointed out by RC.
     666/ 200 :                         	; The result of division is intended to be used as the input for the
     667/ 200 :                         	; next digit conversion.
     668/ 200 :                         	; The RA register manipulates the content of the `tmp_conv` buffer.
     669/ 200 :                         	; The RD register points to a radix (divisor).
     670/ 200 :                         	; A callee sets the high parts of all registers. This function does not
     671/ 200 :                         	; change them.
     672/ 200 :                         	; ---------------------------------------------------------------------
     673/ 200 : F8 10                   	LDI	lo(radix)		; let RD point to `radix`
     674/ 202 : AD                      	PLO	RD
     675/ 203 : F8 0E                   	LDI	lo(tmp_conv+1)		; let RA point to the first byte of the dividend
     676/ 205 : AA                      	PLO	RA
     677/ 206 :                         
     678/ 206 :                         	; If the dividend is zero, return without performing any conversion.
     679/ 206 :                         	; Note: the dividend is stored in the 2nd and 3rd position of the `tmp_conv` buffer.
     680/ 206 : 4A                      	LDA	RA			; load the 2nd byte in the buffer
     681/ 207 : 3A 0D                   	BNZ	dec_conv		; the 2nd byte is not zero, perform the conversion
     682/ 209 : 0A                      	LDN	RA			; load the 3rd byte
     683/ 20A : 3A 0D                   	BNZ	dec_conv		; the 3rd byte is not zero, perform the conversion
     684/ 20C : D5                      	SEP	R5			; all tested bytes were zero; return immediately.
     685/ 20D :                         
     686/ 20D :                         dec_conv:
     687/ 20D :                         	; Move the `prt_buf` index to where the current conversion result character will be stored.
     688/ 20D : 2C                      	DEC	RC
     689/ 20E :                         
     690/ 20E :                         	; Make RA point to the last byte of `tmp_conv`. It assumes the high part of RA has already been initialized.
     691/ 20E : F8 0F                   	LDI	lo(tmp_conv+2)
     692/ 210 : AA                      	PLO	RA
     693/ 211 :                         
     694/ 211 :                         	; The loop divides a 16-bit value with an 8-bit value. Each loop iteration calculates 1 bit of the result.
     695/ 211 :                         	; The remainder is in the first byte. The following 2 bytes hold the division result.
     696/ 211 : F8 10                   	LDI	16			; 16 iterations
     697/ 213 :                         dec_digit_loop:
     698/ 213 :                         	; Shift left 3 bytes buffer content, and if the value in the 1st byte is greater or equal to radix,
     699/ 213 :                         	; add 1 to the last byte.
     700/ 213 : 73                      	STXD				; preserve the loop counter onto the stack
     701/ 214 :                         
     702/ 214 :                         	; Shift-left the 3rd byte in `tmp_conv`, putting 0 to the lsb position.
     703/ 214 : EA                      	SEX	RA			; make RA index
     704/ 215 : 0A                      	LDN	RA			; note that RA points to the last byte within the buffer
     705/ 216 : FE                      	SHL
     706/ 217 : 73                      	STXD
     707/ 218 :                         
     708/ 218 :                         	; Shift-left the 2nd byte in `tmp_conv`, filling the lsb position from the DF.
     709/ 218 : 0A                      	LDN	RA
     710/ 219 : 7E                      	SHLC
     711/ 21A : 73                      	STXD
     712/ 21B :                         
     713/ 21B :                         	; Shift-left the 1st byte in `tmp_conv`, filling the lsb position from the DF.
     714/ 21B : 0A                      	LDN	RA
     715/ 21C : 7E                      	SHLC
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 15 - 19/03/25 16:29:15


     716/ 21D : 5A                      	STR	RA
     717/ 21E :                         
     718/ 21E :                         	; D holds the 1st byte of `tmp_conv` that we want to compare with the radix.
     719/ 21E : ED                      	SEX	RD			; point to radix
     720/ 21F : F7                      	SM				; if the prefix is greater or equal to the radix, the result is non-negative
     721/ 220 : E2                      	SEX	R2			; restore the default index register
     722/ 221 : 3B 2D                   	BM	dec_prefix_less		; if the prefix is less than radix, skip subtraction
     723/ 223 :                         
     724/ 223 :                         	; The prefix in the 1st byte of `tmp_conv` was greater or equal to `radix`.
     725/ 223 :                         	; Store the result of the subtraction in the 1st byte of `tmp_conv` and add 1 to the last byte of the
     726/ 223 :                         	; intermediate result. As the last bit of the last byte of `tmp_conv` was zero after the previous shifting,
     727/ 223 :                         	; adding 1 cannot cause the overflow.
     728/ 223 : 5A                      	STR	RA			; store the subtraction result in the 1st byte of `tmp_conv`
     729/ 224 : F8 0F                   	LDI	lo(tmp_conv+2)		; point to the last byte of `tmp_conv`
     730/ 226 : AA                      	PLO	RA
     731/ 227 : 0A                      	LDN	RA			; add 1 to the last byte of `tmp_conv`
     732/ 228 : FC 01                   	ADI	1
     733/ 22A : 5A                      	STR	RA			; store the updated last byte of `tmp_conv`
     734/ 22B : 30 30                   	BR	dec_test_if_done	; go to loop counter checking
     735/ 22D :                         
     736/ 22D :                         dec_prefix_less:
     737/ 22D :                         	; Let RA point to the last part of `tmp_conv`.
     738/ 22D : F8 0F                   	LDI	lo(tmp_conv+2)
     739/ 22F : AA                      	PLO	RA
     740/ 230 :                         
     741/ 230 :                         dec_test_if_done
     742/ 230 :                         	; Test if all 16 bits of the division have been calculated
     743/ 230 : 60                      	IRX				; restore the loop counter from the stack
     744/ 231 : F0                      	LDX
     745/ 232 : FF 01                   	SMI	1			; decrease the loop counter
     746/ 234 : 3A 13                   	BNZ	dec_digit_loop		; if the counter is greater than zero, do another loop
     747/ 236 :                         
     748/ 236 :                         	; The division is completed; the remainder is in the 1st byte of the `tmp_conv` buffer.
     749/ 236 :                         	; Convert it to a character and store it in the correct position within the `prt_buf`.
     750/ 236 : F8 0D                   	LDI	lo(tmp_conv)		; restore the RA to the beginning of `tmp_conv`
     751/ 238 : AA                      	PLO	RA
     752/ 239 : 0A                      	LDN	RA			; load the remainder byte
     753/ 23A : FC 30                   	ADI	'0'			; make it a character
     754/ 23C : 5C                      	STR	RC			; store it into the current position within `str_buf`
     755/ 23D : F8 00                   	LDI	0			; clear the first byte of `tmp_conv` for the next iteration
     756/ 23F : 5A                      	STR	RA
     757/ 240 :                         	; return
     758/ 240 : D5                      	SEP	R5
     759/ 241 :                         
     760/ 241 :                         
     761/ 241 :                         ; -----------------------------------------------------------------------------
     762/ 241 :                         ; Variables reside in the space from 0x0300 to 0x03FF.
     763/ 241 :                         ; The 16-bit values are stored using the big-endian notation.
     764/ 241 :                         ; -----------------------------------------------------------------------------
     765/ 300 :                         	ORG	(code+0x0300)
     766/ 300 :                         vars:
     767/ 300 :                         mark_mask:
     768/ 300 :                         	; bitmask used to update a `sieve` byte
     769/ 300 :                         	; it is placed on a page boundary position to optimize the code.
     770/ 300 : 80                      	DB	0b10000000
     771/ 301 : 40                      	DB	0b01000000
     772/ 302 : 20                      	DB	0b00100000
     773/ 303 : 10                      	DB	0b00010000
     774/ 304 : 08                      	DB	0b00001000
     775/ 305 : 04                      	DB	0b00000100
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 16 - 19/03/25 16:29:15


     776/ 306 : 02                      	DB	0b00000010
     777/ 307 : 01                      	DB	0b00000001
     778/ 308 :                         prt_mask:
     779/ 308 :                         	; bitmask used when testing whether to print a number associated with a bit in the `sieve`
     780/ 308 : 80                      	DB	0b10000000
     781/ 309 :                         tmp_mark:
     782/ 309 :                         	; the 16-bit number being tested or printed
     783/ 309 : 00 00                   	DB	0, 0
     784/ 30B :                         step:
     785/ 30B :                         	; the increment value for the loop that marks composites within the `sieve`
     786/ 30B :                         	; it is usually twice the value of the current prime
     787/ 30B : 00 00                   	DB	0, 0
     788/ 30D :                         tmp_conv:
     789/ 30D :                         	; used for 16-bit division
     790/ 30D : 00 00 00                	DB	0, 0, 0
     791/ 310 :                         radix:
     792/ 310 :                         	; used to covert the number for printing
     793/ 310 : 0A                      	DB	10
     794/ 311 :                         prt_buf:
     795/ 311 :                         	; buffer where the converted number is stored for printing
     796/ 311 : 20 00 00 00 00 30 00    	DB	' ', 0, 0, 0, 0, '0', 0
     797/ 318 :                         prt_buf_end:
     798/ 318 :                         
     799/ 318 :                         initial_msg:
     800/ 318 : 0D 0A 50 6C 65 61 73 65 	DB	"\r\nPlease wait a moment while I am populating the sieve of Eratosthenes ...\n\r\0"
          320 : 20 77 61 69 74 20 61 20
          328 : 6D 6F 6D 65 6E 74 20 77
          330 : 68 69 6C 65 20 49 20 61
          338 : 6D 20 70 6F 70 75 6C 61
          340 : 74 69 6E 67 20 74 68 65
          348 : 20 73 69 65 76 65 20 6F
          350 : 66 20 45 72 61 74 6F 73
          358 : 74 68 65 6E 65 73 20 2E
          360 : 2E 2E 0A 0D 00         
     801/ 365 :                         print_start_msg:
     802/ 365 : 0D 0A 50 72 69 6D 65 20 	DB	"\r\nPrime numbers less than 65536\r\n\0"
          36D : 6E 75 6D 62 65 72 73 20
          375 : 6C 65 73 73 20 74 68 61
          37D : 6E 20 36 35 35 33 36 0D
          385 : 0A 00                  
     803/ 387 :                         final_msg:
     804/ 387 : 0D 0A 50 72 65 73 73 20 	DB	"\r\nPress <ENTER> to return to the monitor\r\n\0"
          38F : 3C 45 4E 54 45 52 3E 20
          397 : 74 6F 20 72 65 74 75 72
          39F : 6E 20 74 6F 20 74 68 65
          3A7 : 20 6D 6F 6E 69 74 6F 72
          3AF : 0D 0A 00               
     805/ 3B2 :                         
     806/ 3B2 :                         
     807/ 3B2 :                         ; -----------------------------------------------------------------------------
     808/ 3B2 :                         ; Reserve the space for SCRT stack (R6) from 0x0400 to 0x047F
     809/ 3B2 :                         ; -----------------------------------------------------------------------------
     810/ 47F :                         	ORG	(code+0x047F)
     811/ 47F :                         scrt_stack:
     812/ 47F :                         
     813/ 47F :                         
     814/ 47F :                         ; -----------------------------------------------------------------------------
     815/ 47F :                         ; Reserve the space for the standard stack (R2) from 0x0480 to 0x04FF
     816/ 47F :                         ; -----------------------------------------------------------------------------
     817/ 4FF :                         	ORG	(code+0x04FF)
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 17 - 19/03/25 16:29:15


     818/ 4FF :                         stack:
     819/ 4FF :                         
     820/ 4FF :                         
     821/ 4FF :                         ; -----------------------------------------------------------------------------
     822/ 4FF :                         ; The array holding the Sieve of Eratosthenes
     823/ 4FF :                         ; Note: the sieve is represented in the LSB-first order, i.e., 1 is the leftmost
     824/ 4FF :                         ; bit of the 1st byte, and 65535 is the rightmost bit of the last byte.
     825/ 4FF :                         ; -----------------------------------------------------------------------------
     826/2000 :                         	ORG	(0x2000)
     827/2000 :                         sieve:
     828/4000 :                         	ORG	(0x4000)
     829/4000 :                         sieve_end:
     830/4000 :                         
     831/4000 :                         
     832/4000 :                         ; -----------------------------------------------------------------------------
     833/4000 :                         ; Monitor routines called by this program:
     834/4000 :                         ; -----------------------------------------------------------------------------
     835/8000 :                         	ORG	0x8000		; monitor entry point
     836/8000 :                         monitor:
     837/8000 :                         
     838/8000 :                         ;	ORG	0x80A3		; mon_get_ch
     839/8000 :                         ;mon_get_ch:
     840/8000 :                         
     841/8000 :                         ;	ORG	0x8100		; mon_put_ch
     842/8000 :                         ;mon_put_ch:
     843/8000 :                         
     844/8519 :                         	ORG	0x8519		; mon_crlf
     845/8519 :                         mon_crlf:
     846/8519 :                         
     847/85BF :                         	ORG	0x85BF		; mon_prt_b_hex
     848/85BF :                         mon_prt_b_hex:
     849/85BF :                         
     850/8526 :                         	ORG	0x8526		; mon_put_str
     851/8526 :                         mon_put_str:
     852/8526 :                         
     853/8ADB :                         	ORG	0x8ADB		; SCRT call subroutine invoked by SEP R4 and using R6 as SP
     854/8ADB :                         mon_scrt_call:
     855/8ADB :                         
     856/8AED :                         	ORG	0x8AED		; SCRT return subroutine invoked by SEP R5 and using R6 as SP
     857/8AED :                         mon_scrt_return:
     858/8AED :                         
 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 18 - 19/03/25 16:29:15


  Symbol Table (* = unused):
  --------------------------

*ARCHITECTURE :                                      "x86_64-unknown-linux" - |
*BITFUNCSINC :                    1 - | *CASESENSITIVE :                  0 - |
 CODE :                           0 C | *CONSTPI :     3.141592653589793239 - |
*DATE :                  "19/03/25" - |  DEC_CONV :                     20D C |
 DEC_DIGIT :                    200 C |  DEC_DIGIT_LOOP :               213 C |
 DEC_PREFIX_LESS :              22D C |  DEC_TEST_IF_DONE :             230 C |
*FALSE :                          0 - |  FINAL_MSG :                    387 C |
*FLOATMAX :   1.18973149535725E4932 - | *HAS64 :                          1 - |
 INITIAL_MSG :                  318 C |  INIT_LOOP :                     34 C |
 INNER_MARKING_LOOP :           0DA C | *LISTON :                         1 - |
*MACEXP :                         7 - |  MAIN :                          21 C |
 MARK_MASK :                    300 C | *MOMCPU :                      1802 - |
*MOMCPUNAME :                "1802" - |  MONITOR :                     8000 C |
 MON_CRLF :                    8519 C | *MON_PRT_B_HEX :               85BF C |
 MON_PUT_STR :                 8526 C |  MON_SCRT_CALL :               8ADB C |
 MON_SCRT_RETURN :             8AED C | *NESTMAX :                      100 - |
 NEXT_MARKING_NUMBER :          11F C |  OUTER_MARKING_LOOP :            6F C |
*PRINT_LOOP_END :               164 C | *PRINT_RESULT :                 125 C |
 PRINT_RES_LOOP :               142 C |  PRINT_RES_MASK_LOOP :          145 C |
 PRINT_START_MSG :              365 C |  PRT_16B_NUM :                  16E C |
 PRT_BUF :                      311 C |  PRT_BUF_END :                  318 C |
 PRT_MASK :                     308 C |  PRT_SKIP_NOT_PRIME :           158 C |
 R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - |  R3 :                             3 - |
 R4 :                             4 - |  R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RA :                            0A - |  RADIX :                        310 C |
*RB :                            0B - |  RC :                            0C - |
 RD :                            0D - | *RE :                            0E - |
*RELAXED :                        1 - | *RF :                            0F - |
 SCRT_STACK :                   47F C |  SIEVE :                       2000 C |
 SIEVE_END :                   4000 C |  SQUARE_RES :                   0D5 C |
 SQ_AFTER_SUM :                 0CD C |  SQ_LOOP :                      0BF C |
 STACK :                        4FF C |  STEP :                         30B C |
*TIME :                  "16:29:15" - |  TMP_CONV :                     30D C |
 TMP_MARK :                     309 C | *TRUE :                           1 - |
 VARS :                         300 C | *VERSION :                     142F - |

     75 symbols
     24 unused symbols

 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 19 - 19/03/25 16:29:15


  Defined Functions:
  ------------------

ROTRN                                 | ROTLN                                
SHRN                                  | SHLN                                 
GETBIT                                | EVEN                                 
ODD                                   | LOWORD                               
HIWORD                                | LO                                   
HI                                    | CUTOUT                               
INVMASK                               | MASK                                 

 AS V1.42 Beta [Bld 281] - Source File sieve.asm - Page 20 - 19/03/25 16:29:15


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.01 seconds assembly time

    939 lines source file
   1055 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
