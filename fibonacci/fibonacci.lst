 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 1 - 20/03/25 19:12:37


       1/   0 :                         ; -----------------------------------------------------------------------------
       2/   0 :                         ; SPDX-FileCopyrightText: © 2024 Damir Maleničić,
       3/   0 :                         ; SPDX-License-Identifier: MIT
       4/   0 :                         ; -----------------------------------------------------------------------------
       5/   0 :                         ; Calculates the Fibonacci numbers that fit into 32-bit or 64-bit numbers.
       6/   0 :                         ; -----------------------------------------------------------------------------
       7/   0 :                         ; Register allocation is partially imposed by the integration with Chuck's monitor:
       8/   0 :                         ; R0 - reset program counter and SP, PC, and SP for user programs invoked with the
       9/   0 :                         ;      `R` command, a memory pointer during the `DMA` transfer
      10/   0 :                         ; R1 - the interrupt program counter
      11/   0 :                         ; R2 - a stack pointer for the main function and interrupt routines
      12/   0 :                         ; R3 - program counter for the main function
      13/   0 :                         ; R4 - program counter for SCRT subroutine calls
      14/   0 :                         ; R5 - program counter for SCRT subroutine returns
      15/   0 :                         ; R6 - SCRT return address stack pointer
      16/   0 :                         ; R7 - a pointer to a string to be written when invoking `mon_put_str` on location 8526
      17/   0 :                         ; R8 - points to the first operand in Fibonacci summation
      18/   0 :                         ; R9 - points to the second operand in Fibonacci summation
      19/   0 :                         ; RA, RC, RD - scratch-pad registers for calculating and printing the results
      20/   0 :                         ; RB.HI - holds the input character classification
      21/   0 :                         ; RB.LO - holds the input character or the output character
      22/   0 :                         ; RE.HI - by the monitor program convention, it holds 01
      23/   0 :                         ; RE.LO - holds the UART baud rate indicator
      24/   0 :                         ; RF.HI - used by SCRT call and return subroutines to preserve the value of D
      25/   0 :                         ;         register between caller and callee
      26/   0 :                         ; -----------------------------------------------------------------------------
      27/   0 :                         ; It is assembled using
      28/   0 :                         ; [The Macro Assembler AS](http://john.ccac.rwth-aachen.de:8000/as/), but
      29/   0 :                         ; the code should be portable to other 1802 assemblers.
      30/   0 :                         ; The following instructions can be used to assemble and link the program:
      31/   0 :                         ; ```
      32/   0 :                         ; asl -cpu 1802 -L fibonacci.asm
      33/   0 :                         ; p2hex 8-queens.p fibonacci.hex
      34/   0 :                         ; ```
      35/   0 :                         ; -----------------------------------------------------------------------------
      36/   0 :                         
      37/   0 :                         
      38/   0 :                         ; enable C style numeric constants --------------------------------------------
      39/   0 :                         
      40/   0 :                                 RELAXED ON
      41/   0 :                         
      42/   0 :                         
      43/   0 :                         ; define the processor the code should be generated for -----------------------
      44/   0 :                         ; The code is intended for the RCA 1802 processor.
      45/   0 :                         
      46/   0 :                                 CPU     1802
      47/   0 :                         
      48/   0 :                         
      49/   0 :                         ; include the bit manipulation functions --------------------------------------
      50/   0 :                         ; This file defines some bit-oriented functions that might be hardwired
      51/   0 :                         ; when using other assemblers.
      52/   0 :                         ; A code uses `hi()` and `lo()` operators that `asl` implements as user-defined
      53/   0 :                         ; function. $ is the synonym for the current PC address.
      54/   0 :                         
      55/   0 :                         
      56/   0 :                                 INCLUDE "bitfuncs.inc"
(1)    1/   0 : =>UNDEFINED             		ifndef   bitfuncsinc    ; avoid multiple inclusion
(1)    2/   0 : =1H                     bitfuncsinc     equ      1
(1)    3/   0 :                         
(1)    4/   0 :                                         save
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm(bitfuncs.inc) - Page 2 - 20/03/25 19:12:37


(1)   77/   0 : ALL                                     restore                 ; allow listing again
(1)   78/   0 :                         
(1)   79/   0 : [1]                                     endif			; bitfuncsinc
(1)   80/   0 :                         
(1)   81/   0 :                         
      57/   0 :                         
      58/   0 :                         
      59/   0 :                         ; -----------------------------------------------------------------------------
      60/   0 :                         ; CONSTANTS
      61/   0 :                         ; -----------------------------------------------------------------------------
      62/   0 :                         ; BYTE_SZ is the number of bytes reserved for a Fibonacci number.
      63/   0 :                         ; Allowed values are 4 or 8.
      64/   0 :                         ; NO_DEC_DIGITS is the number of decimal digits needed to represent a greatest
      65/   0 :                         ; unsigned number that fits in BYTE_SZ bytes.
      66/   0 :                         ; BIT_SZ_STR is a string representation of the number of bits in a BYTE_SZ bytes.
      67/   0 :                         ; -----------------------------------------------------------------------------
      68/   0 : =8H                     BYTE_SZ		EQU	8
      69/   0 :                         
      70/   0 : =>TRUE                  	if BYTE_SZ = 8
      71/   0 :                         
      72/   0 : =14H                    NO_DEC_DIGITS	EQU	20
      73/   0 : ="64"                   BIT_SZ_STR	EQU	"64"
      74/   0 :                         
      75/   0 : =>FALSE                 	elseif BYTE_SZ = 4
      76/   0 :                         N
      77/   0 :                         O_DEC_DIGITS	EQU	10
      78/   0 :                         BIT_SZ_STR	EQU	"32"
      79/   0 :                         
      80/   0 : =>FALSE                 	else
      81/   0 :                         		ERROR "Unsupported BYTE_SZ"
      82/   0 : [70]                    	endif
      83/   0 :                         
      84/   0 :                         
      85/   0 :                         ; -----------------------------------------------------------------------------
      86/   0 :                         ; MACROS
      87/   0 :                         ; -----------------------------------------------------------------------------
      88/   0 :                         
      89/   0 :                         
      90/   0 :                         ; -----------------------------------------------------------------------------
      91/   0 :                         ; Add two (BYTE_SZ*8)-bit numbers: M[a] = M[a]+M[b]
      92/   0 :                         ; a - holds the register pointing to the location of the first operand
      93/   0 :                         ; b - holds the register pointing to the location of the second operand
      94/   0 :                         ; a and b are unchanged
      95/   0 :                         ; If (BYTE_SZ*8)-bit overflow is encountered, end the calculation by jumping
      96/   0 :                         ; to the `fib_l_end` location.
      97/   0 :                         ; -----------------------------------------------------------------------------
      98/   0 :                         add_dp	MACRO a,b
      99/   0 :                         	SEX	a			; let X point to the register holding the 2nd operand address
     100/   0 :                         	GLO	a			; point to the 8th byte of a
     101/   0 :                         	ADI	(BYTE_SZ-1)
     102/   0 :                         	PLO	a
     103/   0 :                         	GLO	b			; point to the 8th byte of b
     104/   0 :                         	ADI	(BYTE_SZ-1)
     105/   0 :                         	PLO	b
     106/   0 :                         	; add the least significant bytes
     107/   0 :                         	LDN	b			; load the 8th byte of a
     108/   0 :                         	ADD				; lo(M[A]) = lo(M[a]) + lo(M[b])
     109/   0 :                         	STXD				; store the 8th byte of a, point to the 7th byte of a
     110/   0 :                         	DEC	b			; point to the 7rd byte of b
     111/   0 :                         	; add with carry the intermediate bytes
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 3 - 20/03/25 19:12:37


     112/   0 :                         	REPT	(BYTE_SZ-2)
     113/   0 :                         	LDN	b			; load the current byte of a
     114/   0 :                         	ADC				; lo(M[A]) = lo(M[a]) + lo(M[b])
     115/   0 :                         	STXD				; store the current byte of a, point to the previous byte of a
     116/   0 :                         	DEC	b			; point to the previous byte of b
     117/   0 :                         	ENDM
     118/   0 :                         	; add with carry the most significant byte
     119/   0 :                         	LDN	b			; load the 1st byte of a
     120/   0 :                         	ADC				; lo(M[A]) = lo(M[a]) + lo(M[b]) + DF
     121/   0 :                         	SEX	R2			; restore X to point to the stack
     122/   0 :                         	BDF	fib_l_end		; if there was a carry, we are over 32-bits; exit
     123/   0 :                         	STR	a			; otherwise, store the 1st byte of a,
     124/   0 :                         	; the pointer to a is on the 1st byte of a
     125/   0 :                         	; the pointer to b is on the 1st byte of b
     126/   0 :                         	ENDM
     127/   0 :                         
     128/   0 :                         
     129/   0 :                         ; register aliases ------------------------------------------------------------
     130/   0 : =0H                     R0      EQU     0
     131/   0 : =1H                     R1      EQU     1
     132/   0 : =2H                     R2      EQU     2
     133/   0 : =3H                     R3      EQU     3
     134/   0 : =4H                     R4      EQU     4
     135/   0 : =5H                     R5      EQU     5
     136/   0 : =6H                     R6      EQU     6
     137/   0 : =7H                     R7      EQU     7
     138/   0 : =8H                     R8      EQU     8
     139/   0 : =9H                     R9      EQU     9
     140/   0 : =0AH                    RA      EQU     10
     141/   0 : =0BH                    RB      EQU     11
     142/   0 : =0CH                    RC      EQU     12
     143/   0 : =0DH                    RD      EQU     13
     144/   0 : =0EH                    RE      EQU     14
     145/   0 : =0FH                    RF      EQU     15
     146/   0 :                         
     147/   0 :                         
     148/   0 :                         ; -----------------------------------------------------------------------------
     149/   0 :                         ; PROGRAM
     150/   0 :                         ; -----------------------------------------------------------------------------
     151/   0 :                                 ORG     0
     152/   0 :                         code:
     153/   0 :                         
     154/   0 :                         	; ---------------------------------------------------------------------
     155/   0 :                         	; Initialize the program
     156/   0 :                         	; ---------------------------------------------------------------------
     157/   0 :                         	; When started after the reset, or by executing the monitor R0000 command:
     158/   0 :                         	; R0 is set to be both the program counter and the stack pointer
     159/   0 :                         	; R1 will become a program counter in the case of an interrupt
     160/   0 :                         	; R2 will become a stack pointer in the case of an interrupt
     161/   0 :                         	; The following section configures the registers::
     162/   0 :                         	; R2 points to the area that will become a stack pointer when control is passed to the main function
     163/   0 :                         	; R3 will become a program counter and point to the main function
     164/   0 :                         	; R4 will point to SCRT call routine
     165/   0 :                         	; R5 will point to SCRT return routine
     166/   0 :                         	; R6 will point to SCRT stack
     167/   0 :                         	; ---------------------------------------------------------------------
     168/   0 :                         
     169/   0 :                         	; Initialize R4 to 0x8ADB and R5 to 0x8AED to enable SCRT.
     170/   0 : F8 8A                   	LDI	hi(mon_scrt_call)
     171/   2 : B4                      	PHI	R4
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 4 - 20/03/25 19:12:37


     172/   3 : B5                      	PHI	R5
     173/   4 : F8 DB                   	LDI	lo(mon_scrt_call)
     174/   6 : A4                      	PLO	R4
     175/   7 : F8 ED                   	LDI	lo(mon_scrt_return)
     176/   9 : A5                      	PLO	R5
     177/   A :                         
     178/   A :                         	; Initialize R6 to SCRT_stack.
     179/   A : F8 02                   	LDI	hi(scrt_stack)
     180/   C : B6                      	PHI	R6
     181/   D : F8 7F                   	LDI	lo(scrt_stack)
     182/   F : A6                      	PLO	R6
     183/  10 :                         
     184/  10 :                         	; Configure R3 to point to the main function.
     185/  10 : F8 21                   	LDI	lo(main)
     186/  12 : A3                      	PLO	R3
     187/  13 : 90                      	GHI	R0
     188/  14 : B3                      	PHI	R3
     189/  15 :                         
     190/  15 :                         	; Configure R2 to point to the stack.
     191/  15 : F8 02                   	LDI	hi(stack)
     192/  17 : B2                      	PHI	R2
     193/  18 : F8 FF                   	LDI	lo(stack)
     194/  1A : A2                      	PLO	R2
     195/  1B :                         
     196/  1B :                         	; Pass the control to the main function.
     197/  1B : E2                      	SEX	R2			; Make R2 the default index register, i.e., the stack pointer.
     198/  1C : D3                      	SEP	R3			; Call the main function.
     199/  1D :                         
     200/  1D :                         	; ---------------------------------------------------------------------
     201/  1D :                         	; The program exit point.
     202/  1D :                         	; ---------------------------------------------------------------------
     203/  1D :                         	; R0 points to this location, so when SEP 0 is executed at the end of the main,
     204/  1D :                         	; the program execution will resume from this point.
     205/  1D : E0                      	SEX	R0			; R0 is now the default index register, similar to what it was after the reset.
     206/  1E : C0 80 00                	LBR	monitor			; Jump to the monitor.
     207/  21 :                         
     208/  21 :                         	; ---------------------------------------------------------------------
     209/  21 :                         	; The main function.
     210/  21 :                         	; ---------------------------------------------------------------------
     211/  21 :                         main:
     212/  21 : F8 02                   	LDI	hi(vars)		; load the page part of the variables section
     213/  23 : B7                      	PHI	R7			; the high part of `vars` holds the page where all strings reside
     214/  24 : B8                      	PHI	R8			; the high part of `first`
     215/  25 : B9                      	PHI	R9			; the high part of `second`
     216/  26 : F8 07                   	LDI	lo(first+BYTE_SZ-1)	; set the low part to the last byte of `first`
     217/  28 : A8                      	PLO	R8
     218/  29 : F8 0F                   	LDI	lo(second+BYTE_SZ-1)	; set the low part to the last byte of  `second`
     219/  2B : A9                      	PLO	R9
     220/  2C :                         
     221/  2C :                         	; print the initial message
     222/  2C : F8 30                   	LDI	lo(initial_msg)
     223/  2E : A7                      	PLO	R7
     224/  2F : D4                      	SEP	R4
     225/  30 : 85                      	DB	hi(mon_put_str)
     226/  31 : 26                      	DB	lo(mon_put_str)
     227/  32 :                         
     228/  32 :                         	; Initialize the `first` and the `second` to enable the program invocation without reloading.
     229/  32 :                         	; Let the `first` be DB 0, 0, 0, 0, 0, 0, 0, 0.
     230/  32 : E8                      	SEX	R8			; temporary make R8 index pointer
     231/  33 : F8 00                   	LDI	0
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 5 - 20/03/25 19:12:37


     232/  35 :                         	REPT	(BYTE_SZ-1)
     233/  35 :                         	STXD
     234/  35 :                         	ENDM
     233/  35 : 73                      	STXD
     233/  36 : 73                      	STXD
     233/  37 : 73                      	STXD
     233/  38 : 73                      	STXD
     233/  39 : 73                      	STXD
     233/  3A : 73                      	STXD
     233/  3B : 73                      	STXD
     235/  3C : 58                      	STR	R8
     236/  3D :                         	; R8 points to the first byte of `first`.
     237/  3D :                         
     238/  3D :                         	; Let the `second` be DB 0, 0, 0, 0, 0, 0, 0, 1.
     239/  3D : E9                      	SEX	R9			; temporary make R9 index pointer
     240/  3E : F8 01                   	LDI	1
     241/  40 : 73                      	STXD
     242/  41 : F8 00                   	LDI	0
     243/  43 :                         	REPT	(BYTE_SZ-2)
     244/  43 :                         	STXD
     245/  43 :                         	ENDM
     244/  43 : 73                      	STXD
     244/  44 : 73                      	STXD
     244/  45 : 73                      	STXD
     244/  46 : 73                      	STXD
     244/  47 : 73                      	STXD
     244/  48 : 73                      	STXD
     246/  49 : 59                      	STR	R9
     247/  4A :                         	; R9 points to the first byte of `second`.
     248/  4A :                         
     249/  4A : E2                      	SEX	R2			; restore the default index pointer
     250/  4B :                         
     251/  4B :                         	; Print the `first` holding the initial 0.
     252/  4B : D4                      	SEP	R4
     253/  4C : 00                      	DB	hi(prt_num)
     254/  4D : B6                      	DB	lo(prt_num)
     255/  4E : 00                      	DB	lo(first)
     256/  4F :                         
     257/  4F :                         	; The fibonacci sequence calculation loop calculates 2 fibonacci numbers per iteration.
     258/  4F :                         	; The exit condition is the 32-bit overflow - see `add_dp` for the macro definition where
     259/  4F :                         	; the check is implemented.
     260/  4F :                         fib_l:
     261/  4F :                         	; Print the `second`.
     262/  4F : D4                      	SEP	R4
     263/  50 : 00                      	DB	hi(prt_num)
     264/  51 : B6                      	DB	lo(prt_num)
     265/  52 : 08                      	DB	lo(second)
     266/  53 :                         
     267/  53 :                         	; first = first+second
     268/  53 : (MACRO)[13]             	add_dp	R8, R9
     268/  53 : E8                              SEX     R8                       ; let X point to the register holding the 2nd operand address
     268/  54 : 88                              GLO     R8                       ; point to the 8th byte of R8
     268/  55 : FC 07                           ADI     (BYTE_SZ-1)
     268/  57 : A8                              PLO     R8
     268/  58 : 89                              GLO     R9                       ; point to the 8th byte of R9
     268/  59 : FC 07                           ADI     (BYTE_SZ-1)
     268/  5B : A9                              PLO     R9
     268/  5C :                                 ; add the least significant bytes
     268/  5C : 09                              LDN     R9                       ; load the 8th byte of R8
     268/  5D : F4                              ADD                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 6 - 20/03/25 19:12:37


     268/  5E : 73                              STXD                            ; store the 8th byte of R8, point to the 7th byte of R8
     268/  5F : 29                              DEC     R9                       ; point to the 7rd byte of R9
     268/  60 :                                 ; add with carry the intermediate bytes
     268/  60 :                                 REPT    (BYTE_SZ-2)
     268/  60 :                                 LDN     R9                       ; load the current byte of R8
     268/  60 :                                 ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  60 :                                 STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  60 :                                 DEC     R9                       ; point to the previous byte of R9
     268/  60 :                                 ENDM
     268/  60 : 09                              LDN     R9                       ; load the current byte of R8
     268/  61 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  62 : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  63 : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  64 : 09                              LDN     R9                       ; load the current byte of R8
     268/  65 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  66 : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  67 : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  68 : 09                              LDN     R9                       ; load the current byte of R8
     268/  69 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  6A : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  6B : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  6C : 09                              LDN     R9                       ; load the current byte of R8
     268/  6D : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  6E : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  6F : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  70 : 09                              LDN     R9                       ; load the current byte of R8
     268/  71 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  72 : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  73 : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  74 : 09                              LDN     R9                       ; load the current byte of R8
     268/  75 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9])
     268/  76 : 73                              STXD                            ; store the current byte of R8, point to the previous byte of R8
     268/  77 : 29                              DEC     R9                       ; point to the previous byte of R9
     268/  78 :                                 ; add with carry the most significant byte
     268/  78 : 09                              LDN     R9                       ; load the 1st byte of R8
     268/  79 : 74                              ADC                             ; lo(M[R8]) = lo(M[R8]) + lo(M[R9]) + DF
     268/  7A : E2                              SEX     R2                      ; restore X to point to the stack
     268/  7B : 33 AF                           BDF     fib_l_end               ; if there was R8 carry, we are over 32-bits; exit
     268/  7D : 58                              STR     R8                       ; otherwise, store the 1st byte of R8,
     268/  7E :                                 ; the pointer to R8 is on the 1st byte of R8
     268/  7E :                                 ; the pointer to R9 is on the 1st byte of R9
     269/  7E :                         
     270/  7E :                         	; Print the `first`
     271/  7E : D4                      	SEP	R4
     272/  7F : 00                      	DB	hi(prt_num)
     273/  80 : B6                      	DB	lo(prt_num)
     274/  81 : 00                      	DB	lo(first)
     275/  82 :                         
     276/  82 :                         	; second = second+first
     277/  82 : (MACRO)[20]             	add_dp	R9, R8
     277/  82 : E9                              SEX     R9                       ; let X point to the register holding the 2nd operand address
     277/  83 : 89                              GLO     R9                       ; point to the 8th byte of R9
     277/  84 : FC 07                           ADI     (BYTE_SZ-1)
     277/  86 : A9                              PLO     R9
     277/  87 : 88                              GLO     R8                       ; point to the 8th byte of R8
     277/  88 : FC 07                           ADI     (BYTE_SZ-1)
     277/  8A : A8                              PLO     R8
     277/  8B :                                 ; add the least significant bytes
     277/  8B : 08                              LDN     R8                       ; load the 8th byte of R9
     277/  8C : F4                              ADD                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 7 - 20/03/25 19:12:37


     277/  8D : 73                              STXD                            ; store the 8th byte of R9, point to the 7th byte of R9
     277/  8E : 28                              DEC     R8                       ; point to the 7rd byte of R8
     277/  8F :                                 ; add with carry the intermediate bytes
     277/  8F :                                 REPT    (BYTE_SZ-2)
     277/  8F :                                 LDN     R8                       ; load the current byte of R9
     277/  8F :                                 ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  8F :                                 STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  8F :                                 DEC     R8                       ; point to the previous byte of R8
     277/  8F :                                 ENDM
     277/  8F : 08                              LDN     R8                       ; load the current byte of R9
     277/  90 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  91 : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  92 : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  93 : 08                              LDN     R8                       ; load the current byte of R9
     277/  94 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  95 : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  96 : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  97 : 08                              LDN     R8                       ; load the current byte of R9
     277/  98 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  99 : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  9A : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  9B : 08                              LDN     R8                       ; load the current byte of R9
     277/  9C : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  9D : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  9E : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  9F : 08                              LDN     R8                       ; load the current byte of R9
     277/  A0 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  A1 : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  A2 : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  A3 : 08                              LDN     R8                       ; load the current byte of R9
     277/  A4 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8])
     277/  A5 : 73                              STXD                            ; store the current byte of R9, point to the previous byte of R9
     277/  A6 : 28                              DEC     R8                       ; point to the previous byte of R8
     277/  A7 :                                 ; add with carry the most significant byte
     277/  A7 : 08                              LDN     R8                       ; load the 1st byte of R9
     277/  A8 : 74                              ADC                             ; lo(M[R9]) = lo(M[R9]) + lo(M[R8]) + DF
     277/  A9 : E2                              SEX     R2                      ; restore X to point to the stack
     277/  AA : 33 AF                           BDF     fib_l_end               ; if there was R9 carry, we are over 32-bits; exit
     277/  AC : 59                              STR     R9                       ; otherwise, store the 1st byte of R9,
     277/  AD :                                 ; the pointer to R9 is on the 1st byte of R9
     277/  AD :                                 ; the pointer to R8 is on the 1st byte of R8
     278/  AD :                         
     279/  AD :                         	; If this point is reached, `add_dp` did not detect a 32-bit overflow.
     280/  AD :                         	; Repeat the Fibonacci sequence calculation loop.
     281/  AD : 30 4F                   	BR	fib_l
     282/  AF :                         
     283/  AF :                         	; This point is reached only if `add_dp` has detected the 32-bit overflow.
     284/  AF :                         fib_l_end:
     285/  AF :                         	; Print the final message and return to the monitor.
     286/  AF : F8 5C                   	LDI	lo(final_msg)
     287/  B1 : A7                      	PLO	R7
     288/  B2 : D4                      	SEP	R4
     289/  B3 : 85                      	DB	hi(mon_put_str)
     290/  B4 : 26                      	DB	lo(mon_put_str)
     291/  B5 :                         
     292/  B5 :                         	; ---------------------------------------------------------------------
     293/  B5 :                         	; Exit main function: return the control to the program exit point.
     294/  B5 :                         	; ---------------------------------------------------------------------
     295/  B5 : D0                      	SEP	R0
     296/  B6 :                         
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 8 - 20/03/25 19:12:37


     297/  B6 :                         
     298/  B6 :                         prt_num:
     299/  B6 :                         	; ---------------------------------------------------------------------
     300/  B6 :                         	; Print a BYTE_SZ bytes number located in a buffer on `vars:` page whose
     301/  B6 :                         	; in-page address is passed in as the inline arguments.
     302/  B6 :                         	; R7 is used as a pointer to a string holding a converted number.
     303/  B6 :                         	; RA, RC and RD are scratch-pad registers for a digit conversion.
     304/  B6 :                         	; All registers except D and DF are preserved.
     305/  B6 :                         	; ---------------------------------------------------------------------
     306/  B6 :                         	; Preserve R7, RA, RC, and RD registers.
     307/  B6 : 97                      	GHI	R7			; use as pointer to a string to print
     308/  B7 : 73                      	STXD
     309/  B8 : 87                      	GLO	R7
     310/  B9 : 73                      	STXD
     311/  BA : 9A                      	GHI	RA			; scratch-pad register for number conversion
     312/  BB : 73                      	STXD
     313/  BC : 8A                      	GLO	RA
     314/  BD : 73                      	STXD
     315/  BE : 9C                      	GHI	RC			; scratch-pad register for number conversion
     316/  BF : 73                      	STXD
     317/  C0 : 8C                      	GLO	RC
     318/  C1 : 73                      	STXD
     319/  C2 : 9D                      	GHI	RD			; scratch-pad register for number conversion
     320/  C3 : 73                      	STXD
     321/  C4 : 8D                      	GLO	RD
     322/  C5 : 73                      	STXD
     323/  C6 :                         
     324/  C6 :                         	; Copy the value pointed to by the provided immediate address to `tmp_conv`.
     325/  C6 :                         	; Note: `tmp_conv` is 1 byte longer than the number to print.
     326/  C6 :                         	; Use RC as the source index and RD as the destination index.
     327/  C6 : 98                      	GHI	R8			; RA.HI, RC.HI and RD.HI are the same as R8.HI (`vars:` page address)
     328/  C7 : BA                      	PHI	RA			; initialize the high part of RA - needed later in `dec_digit`
     329/  C8 : BC                      	PHI	RC			; initialize the high part of RC
     330/  C9 : BD                      	PHI	RD			; initialize the high part of RD
     331/  CA : 46                      	LDA	R6			; load the immediate argument
     332/  CB : AC                      	PLO	RC			; put it in the low part of RC to make RC point to the source buffer
     333/  CC : F8 10                   	LDI	lo(tmp_conv)		; load the low part of `tmp_conv` address
     334/  CE : AD                      	PLO	RD			; put it in the low part of RD to make RD point to the destination buffer
     335/  CF : F8 00                   	LDI	0			; set 0 to the first byte of `tmp_conv`
     336/  D1 : 5D                      	STR	RD
     337/  D2 :                         	REPT	(BYTE_SZ)
     338/  D2 :                         	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  D2 :                         	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  D2 :                         	STR	RD			; store D into the location pointed by the current value of RD
     341/  D2 :                         	ENDM
     338/  D2 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  D3 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  D4 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  D5 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  D6 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  D7 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  D8 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  D9 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  DA : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  DB : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  DC : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  DD : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  DE : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  DF : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  E0 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 9 - 20/03/25 19:12:37


     338/  E1 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  E2 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  E3 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  E4 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  E5 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  E6 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     338/  E7 : 1D                      	INC	RD			; increase RD to point to the next byte of `tmp_conv`
     339/  E8 : 4C                      	LDA	RC			; get the current byte from location pointed by RC into D, then increment RC
     340/  E9 : 5D                      	STR	RD			; store D into the location pointed by the current value of RD
     342/  EA :                         
     343/  EA :                         	; Initialize the string buffer where the decimal conversion result will be written
     344/  EA :                         	; to the default result as if the conversion input was 0.
     345/  EA : F8 2F                   	LDI	lo(prt_buf_end-1)	; the low part points to the end of the print buffer
     346/  EC : AC                      	PLO	RC
     347/  ED : EC                      	SEX	RC			; temporary set RC to act as the index register
     348/  EE : F8 00                   	LDI	0			; the trailing '\0'
     349/  F0 : 73                      	STXD
     350/  F1 : F8 30                   	LDI	'0'			; the corner case for 0, to be overwritten if the input number is not 0
     351/  F3 : 73                      	STXD
     352/  F4 : F8 20                   	LDI	' '			; fill the rest of the buffer with ' '
     353/  F6 :                         	REPT	NO_DEC_DIGITS		; an inline macro that repeats commands till ENDM NO_DEC_DIGITS times
     354/  F6 :                         	STXD
     355/  F6 :                         	ENDM
     354/  F6 : 73                      	STXD
     354/  F7 : 73                      	STXD
     354/  F8 : 73                      	STXD
     354/  F9 : 73                      	STXD
     354/  FA : 73                      	STXD
     354/  FB : 73                      	STXD
     354/  FC : 73                      	STXD
     354/  FD : 73                      	STXD
     354/  FE : 73                      	STXD
     354/  FF : 73                      	STXD
     354/ 100 : 73                      	STXD
     354/ 101 : 73                      	STXD
     354/ 102 : 73                      	STXD
     354/ 103 : 73                      	STXD
     354/ 104 : 73                      	STXD
     354/ 105 : 73                      	STXD
     354/ 106 : 73                      	STXD
     354/ 107 : 73                      	STXD
     354/ 108 : 73                      	STXD
     354/ 109 : 73                      	STXD
     356/ 10A : E2                      	SEX	R2			; restore the default index register
     357/ 10B :                         
     358/ 10B :                         	; Let RC point to the last position of `prt_buf`.
     359/ 10B : F8 2F                   	LDI	lo(prt_buf_end-1)
     360/ 10D : AC                      	PLO	RC
     361/ 10E :                         
     362/ 10E :                         	; Convert the BYTE_SZ bytes unsigned number pointed by RA into a decimal string.
     363/ 10E :                         	; We have at most NO_DEC_DIGITS decimal digits, repeat digit conversion NO_DEC_DIGITS times starting
     364/ 10E :                         	; from the rightmost position.
     365/ 10E :                         	REPT	NO_DEC_DIGITS		; an inline macro that repeats commands till ENDM NO_DEC_DIGITS times
     366/ 10E :                         	SEP	R4			; convert a single digit
     367/ 10E :                         	DB	hi(dec_digit)
     368/ 10E :                         	DB	lo(dec_digit)
     369/ 10E :                         	ENDM
     366/ 10E : D4                      	SEP	R4			; convert a single digit
     367/ 10F : 01                      	DB	hi(dec_digit)
     368/ 110 : 65                      	DB	lo(dec_digit)
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 10 - 20/03/25 19:12:37


     366/ 111 : D4                      	SEP	R4			; convert a single digit
     367/ 112 : 01                      	DB	hi(dec_digit)
     368/ 113 : 65                      	DB	lo(dec_digit)
     366/ 114 : D4                      	SEP	R4			; convert a single digit
     367/ 115 : 01                      	DB	hi(dec_digit)
     368/ 116 : 65                      	DB	lo(dec_digit)
     366/ 117 : D4                      	SEP	R4			; convert a single digit
     367/ 118 : 01                      	DB	hi(dec_digit)
     368/ 119 : 65                      	DB	lo(dec_digit)
     366/ 11A : D4                      	SEP	R4			; convert a single digit
     367/ 11B : 01                      	DB	hi(dec_digit)
     368/ 11C : 65                      	DB	lo(dec_digit)
     366/ 11D : D4                      	SEP	R4			; convert a single digit
     367/ 11E : 01                      	DB	hi(dec_digit)
     368/ 11F : 65                      	DB	lo(dec_digit)
     366/ 120 : D4                      	SEP	R4			; convert a single digit
     367/ 121 : 01                      	DB	hi(dec_digit)
     368/ 122 : 65                      	DB	lo(dec_digit)
     366/ 123 : D4                      	SEP	R4			; convert a single digit
     367/ 124 : 01                      	DB	hi(dec_digit)
     368/ 125 : 65                      	DB	lo(dec_digit)
     366/ 126 : D4                      	SEP	R4			; convert a single digit
     367/ 127 : 01                      	DB	hi(dec_digit)
     368/ 128 : 65                      	DB	lo(dec_digit)
     366/ 129 : D4                      	SEP	R4			; convert a single digit
     367/ 12A : 01                      	DB	hi(dec_digit)
     368/ 12B : 65                      	DB	lo(dec_digit)
     366/ 12C : D4                      	SEP	R4			; convert a single digit
     367/ 12D : 01                      	DB	hi(dec_digit)
     368/ 12E : 65                      	DB	lo(dec_digit)
     366/ 12F : D4                      	SEP	R4			; convert a single digit
     367/ 130 : 01                      	DB	hi(dec_digit)
     368/ 131 : 65                      	DB	lo(dec_digit)
     366/ 132 : D4                      	SEP	R4			; convert a single digit
     367/ 133 : 01                      	DB	hi(dec_digit)
     368/ 134 : 65                      	DB	lo(dec_digit)
     366/ 135 : D4                      	SEP	R4			; convert a single digit
     367/ 136 : 01                      	DB	hi(dec_digit)
     368/ 137 : 65                      	DB	lo(dec_digit)
     366/ 138 : D4                      	SEP	R4			; convert a single digit
     367/ 139 : 01                      	DB	hi(dec_digit)
     368/ 13A : 65                      	DB	lo(dec_digit)
     366/ 13B : D4                      	SEP	R4			; convert a single digit
     367/ 13C : 01                      	DB	hi(dec_digit)
     368/ 13D : 65                      	DB	lo(dec_digit)
     366/ 13E : D4                      	SEP	R4			; convert a single digit
     367/ 13F : 01                      	DB	hi(dec_digit)
     368/ 140 : 65                      	DB	lo(dec_digit)
     366/ 141 : D4                      	SEP	R4			; convert a single digit
     367/ 142 : 01                      	DB	hi(dec_digit)
     368/ 143 : 65                      	DB	lo(dec_digit)
     366/ 144 : D4                      	SEP	R4			; convert a single digit
     367/ 145 : 01                      	DB	hi(dec_digit)
     368/ 146 : 65                      	DB	lo(dec_digit)
     366/ 147 : D4                      	SEP	R4			; convert a single digit
     367/ 148 : 01                      	DB	hi(dec_digit)
     368/ 149 : 65                      	DB	lo(dec_digit)
     370/ 14A :                         
     371/ 14A :                         	; print the string holding the conversion result, R7 is a pointer to null-terminated string
     372/ 14A : F8 1A                   	LDI	lo(prt_buf)
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 11 - 20/03/25 19:12:37


     373/ 14C : A7                      	PLO	R7
     374/ 14D : D4                      	SEP	R4
     375/ 14E : 85                      	DB	hi(mon_put_str)
     376/ 14F : 26                      	DB	lo(mon_put_str)
     377/ 150 :                         
     378/ 150 :                         	; print <CR><LF>
     379/ 150 : D4                      	SEP	R4
     380/ 151 : 85                      	DB	hi(mon_crlf)
     381/ 152 : 19                      	DB	lo(mon_crlf)
     382/ 153 :                         
     383/ 153 :                         	; restore R7,RA,RC,RD register
     384/ 153 : 60                      	IRX
     385/ 154 : 72                      	LDXA				; restore RD
     386/ 155 : AD                      	PLO	RD
     387/ 156 : 72                      	LDXA
     388/ 157 : BD                      	PHI	RD
     389/ 158 : 72                      	LDXA				; restore RC
     390/ 159 : AC                      	PLO	RC
     391/ 15A : 72                      	LDXA
     392/ 15B : BC                      	PHI	RC
     393/ 15C : 72                      	LDXA				; restore RA
     394/ 15D : AA                      	PLO	RA
     395/ 15E : 72                      	LDXA
     396/ 15F : BA                      	PHI	RA
     397/ 160 : 72                      	LDXA				; restore R7
     398/ 161 : A7                      	PLO	R7
     399/ 162 : F0                      	LDX
     400/ 163 : B7                      	PHI	R7
     401/ 164 :                         	; return
     402/ 164 : D5                      	SEP	R5
     403/ 165 :                         
     404/ 165 :                         
     405/ 165 :                         dec_digit:
     406/ 165 :                         	; ---------------------------------------------------------------------
     407/ 165 :                         	; This function converts the single decimal digit by dividing the number
     408/ 165 :                         	; in `tmp_conv` by the number in `radix` and writes the result
     409/ 165 :                         	; to the correct position in `prt_buf`. It is intended to be called
     410/ 165 :                         	; as many times as necessary to convert the whole number.
     411/ 165 :                         	; `tmp_conv` is BYTE_SZ+1 bytes long, the 1st byte is 0 on input, while the other,
     412/ 165 :                         	; bytes hold the number to be converted.
     413/ 165 :                         	; As per RCA 1802 convention, the big-endian notation is used.
     414/ 165 :                         	; If the number in `tmp_conv` is 0, the function returns immediately;
     415/ 165 :                                 ; otherwise, it divides that number by a radix value.
     416/ 165 :                         	; The division is performed in place, the result replaces the dividend,
     417/ 165 :                         	; and the remainder is held in the 1st byte of the `tmp_conv` buffer.
     418/ 165 :                         	; The remainder is converted to a character and written in the memory
     419/ 165 :                         	; location pointed out by RC.
     420/ 165 :                         	; The result of division is intended to be used as the input for the
     421/ 165 :                         	; next digit conversion.
     422/ 165 :                         	; The RA register manipulates the content of the `tmp_conv` buffer.
     423/ 165 :                         	; The RD register points to a radix (divisor).
     424/ 165 :                         	; A callee sets the high parts of all registers. This function does not
     425/ 165 :                         	; change them.
     426/ 165 :                         	; ---------------------------------------------------------------------
     427/ 165 : F8 19                   	LDI	lo(radix)		; let RD point to `radix`
     428/ 167 : AD                      	PLO	RD
     429/ 168 : F8 11                   	LDI	lo(tmp_conv+1)		; let RA point to the first byte of the dividend
     430/ 16A : AA                      	PLO	RA
     431/ 16B :                         
     432/ 16B :                         	; If the dividend is zero, return without performing any conversion.
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 12 - 20/03/25 19:12:37


     433/ 16B :                         	; Note: the dividend is stored from the 2nd position of the `tmp_conv` buffer.
     434/ 16B :                         	REPT	BYTE_SZ
     435/ 16B :                         	LDA	RA			; load the current dividend byte in the buffer
     436/ 16B :                         	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     437/ 16B :                         	ENDM
     435/ 16B : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 16C : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 16E : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 16F : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 171 : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 172 : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 174 : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 175 : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 177 : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 178 : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 17A : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 17B : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 17D : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 17E : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     435/ 180 : 4A                      	LDA	RA			; load the current dividend byte in the buffer
     436/ 181 : 3A 84                   	BNZ	dec_conv		; the current dividend byte is not zero, perform the conversion
     438/ 183 : D5                      	SEP	R5			; the dividend is zero, return
     439/ 184 :                         
     440/ 184 :                         dec_conv:
     441/ 184 :                         	; Move the `prt_buf` index to where the current conversion result character will be stored.
     442/ 184 : 2C                      	DEC	RC
     443/ 185 :                         
     444/ 185 :                         	; Make RA point to the last byte of `tmp_conv`. It assumes the high part of RA has already been initialized.
     445/ 185 : F8 18                   	LDI	lo(tmp_conv_end-1)
     446/ 187 : AA                      	PLO	RA
     447/ 188 :                         
     448/ 188 :                         	; The loop divides a BYTE_SZ bytes value with an 8-bit value. Each loop iteration calculates
     449/ 188 :                         	; 1 bit of the result.
     450/ 188 :                         	; The remainder is in the first byte. The following 8 bytes hold the division result.
     451/ 188 : F8 40                   	LDI	(BYTE_SZ*8)		; Number of iterations equals number of bits
     452/ 18A :                         dec_digit_loop:
     453/ 18A :                         	; Shift left (BYTE_SZ+1) bytes buffer content, and if the value in the 1st byte is
     454/ 18A :                         	; greater or equal to radix, add 1 to the last byte.
     455/ 18A : 73                      	STXD				; preserve the loop counter onto the stack
     456/ 18B :                         
     457/ 18B :                         	; Shift-left the most significant byte in `tmp_conv`, putting 0 to the lsb position.
     458/ 18B : 0A                      	LDN	RA			; note that RA points to the last byte within the buffer
     459/ 18C : FE                      	SHL
     460/ 18D : 5A                      	STR	RA
     461/ 18E : 2A                      	DEC	RA
     462/ 18F :                         
     463/ 18F :                         	; shift left other bytes in `tmp_conv` moving from less significant toward more significant,
     464/ 18F :                         	; and filling the lsb of each byte from DF
     465/ 18F :                         	REPT	(BYTE_SZ-1)
     466/ 18F :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 18F :                         	LDN	RA
     468/ 18F :                         	SHLC
     469/ 18F :                         	STR	RA
     470/ 18F :                         	DEC	RA
     471/ 18F :                         	ENDM
     466/ 18F :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 18F : 0A                      	LDN	RA
     468/ 190 : 7E                      	SHLC
     469/ 191 : 5A                      	STR	RA
     470/ 192 : 2A                      	DEC	RA
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 13 - 20/03/25 19:12:37


     466/ 193 :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 193 : 0A                      	LDN	RA
     468/ 194 : 7E                      	SHLC
     469/ 195 : 5A                      	STR	RA
     470/ 196 : 2A                      	DEC	RA
     466/ 197 :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 197 : 0A                      	LDN	RA
     468/ 198 : 7E                      	SHLC
     469/ 199 : 5A                      	STR	RA
     470/ 19A : 2A                      	DEC	RA
     466/ 19B :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 19B : 0A                      	LDN	RA
     468/ 19C : 7E                      	SHLC
     469/ 19D : 5A                      	STR	RA
     470/ 19E : 2A                      	DEC	RA
     466/ 19F :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 19F : 0A                      	LDN	RA
     468/ 1A0 : 7E                      	SHLC
     469/ 1A1 : 5A                      	STR	RA
     470/ 1A2 : 2A                      	DEC	RA
     466/ 1A3 :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 1A3 : 0A                      	LDN	RA
     468/ 1A4 : 7E                      	SHLC
     469/ 1A5 : 5A                      	STR	RA
     470/ 1A6 : 2A                      	DEC	RA
     466/ 1A7 :                         	; Shift-left the current byte in `tmp_conv`, filling the lsb position from the DF.
     467/ 1A7 : 0A                      	LDN	RA
     468/ 1A8 : 7E                      	SHLC
     469/ 1A9 : 5A                      	STR	RA
     470/ 1AA : 2A                      	DEC	RA
     472/ 1AB : 0A                      	LDN	RA
     473/ 1AC : 7E                      	SHLC
     474/ 1AD : 5A                      	STR	RA
     475/ 1AE :                         
     476/ 1AE :                         	; D holds the 1st byte of `tmp_conv` that we want to compare with the radix.
     477/ 1AE : ED                      	SEX	RD			; point to radix
     478/ 1AF : F7                      	SM				; if the prefix is greater or equal to the radix, the result is non-negative
     479/ 1B0 : E2                      	SEX	R2			; restore the default index register
     480/ 1B1 : 3B BD                   	BM	dec_prefix_less		; if the prefix is less than radix, skip subtraction
     481/ 1B3 :                         
     482/ 1B3 :                         	; The prefix in the 1st byte of `tmp_conv` was greater or equal to `radix`.
     483/ 1B3 :                         	; Store the result of the subtraction in the 1st byte of `tmp_conv` and add 1 to the last byte of the
     484/ 1B3 :                         	; intermediate result. As the last bit of the last byte of `tmp_conv` was zero after the previous shifting,
     485/ 1B3 :                         	; adding 1 cannot cause the overflow.
     486/ 1B3 : 5A                      	STR	RA			; store the subtraction result in the 1st byte of `tmp_conv`
     487/ 1B4 : F8 18                   	LDI	lo(tmp_conv+BYTE_SZ)	; point to the last byte of `tmp_conv`
     488/ 1B6 : AA                      	PLO	RA
     489/ 1B7 : 0A                      	LDN	RA			; add 1 to the last byte of `tmp_conv`
     490/ 1B8 : FC 01                   	ADI	1
     491/ 1BA : 5A                      	STR	RA			; store the updated last byte of `tmp_conv`
     492/ 1BB : 30 C0                   	BR	dec_test_if_done	; go to loop counter checking
     493/ 1BD :                         
     494/ 1BD :                         dec_prefix_less:
     495/ 1BD :                         	; Let RA point to the last part of `tmp_conv`.
     496/ 1BD : F8 18                   	LDI	lo(tmp_conv+BYTE_SZ)
     497/ 1BF : AA                      	PLO	RA
     498/ 1C0 :                         
     499/ 1C0 :                         dec_test_if_done
     500/ 1C0 :                         	; Test if all 32-bits of the division have been calculated
     501/ 1C0 : 60                      	IRX				; restore the loop counter from the stack
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 14 - 20/03/25 19:12:37


     502/ 1C1 : F0                      	LDX
     503/ 1C2 : FF 01                   	SMI	1			; decrease the loop counter
     504/ 1C4 : 3A 8A                   	BNZ	dec_digit_loop		; if the counter is greater than zero, do another loop
     505/ 1C6 :                         
     506/ 1C6 :                         	; The division is completed; the remainder is in the 1st byte of the `tmp_conv` buffer.
     507/ 1C6 :                         	; Convert it to a character and store it in the correct position within the `prt_buf`.
     508/ 1C6 : F8 10                   	LDI	lo(tmp_conv)		; restore the RA to the beginning of `tmp_conv`
     509/ 1C8 : AA                      	PLO	RA
     510/ 1C9 : 0A                      	LDN	RA			; load the remainder byte
     511/ 1CA : FC 30                   	ADI	'0'			; make it a character
     512/ 1CC : 5C                      	STR	RC			; store it into the current position within `str_buf`
     513/ 1CD : F8 00                   	LDI	0			; clear the first byte of `tmp_conv` for the next iteration
     514/ 1CF : 5A                      	STR	RA
     515/ 1D0 :                         	; return
     516/ 1D0 : D5                      	SEP	R5
     517/ 1D1 :                         
     518/ 1D1 :                         
     519/ 1D1 :                         ; -----------------------------------------------------------------------------
     520/ 1D1 :                         ; Variables reside in the space from 0x0180 to 0x01FF.
     521/ 1D1 :                         ; The 32-bit values are stored using the big-endian notation.
     522/ 1D1 :                         ; -----------------------------------------------------------------------------
     523/ 200 :                         	ORG	(code+0x0200)
     524/ 200 :                         vars:
     525/ 200 :                         first:
     526/ 200 :                         	; The first argument for the Fibonacci step
     527/ 200 :                         	REPT	BYTE_SZ
     528/ 200 :                         	DB	0
     529/ 200 :                         	ENDM
     528/ 200 : 00                      	DB	0
     528/ 201 : 00                      	DB	0
     528/ 202 : 00                      	DB	0
     528/ 203 : 00                      	DB	0
     528/ 204 : 00                      	DB	0
     528/ 205 : 00                      	DB	0
     528/ 206 : 00                      	DB	0
     528/ 207 : 00                      	DB	0
     530/ 208 :                         first_end:
     531/ 208 :                         second:
     532/ 208 :                         	; The second argument for the Fibonacci step
     533/ 208 :                         	REPT	(BYTE_SZ-1)
     534/ 208 :                         	DB	0
     535/ 208 :                         	ENDM
     534/ 208 : 00                      	DB	0
     534/ 209 : 00                      	DB	0
     534/ 20A : 00                      	DB	0
     534/ 20B : 00                      	DB	0
     534/ 20C : 00                      	DB	0
     534/ 20D : 00                      	DB	0
     534/ 20E : 00                      	DB	0
     536/ 20F : 01                      	DB	1
     537/ 210 :                         second_end:
     538/ 210 :                         tmp_conv:
     539/ 210 :                         	; used for long division
     540/ 210 :                         	REPT	(BYTE_SZ+1)
     541/ 210 :                         	DB	0
     542/ 210 :                         	ENDM
     541/ 210 : 00                      	DB	0
     541/ 211 : 00                      	DB	0
     541/ 212 : 00                      	DB	0
     541/ 213 : 00                      	DB	0
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 15 - 20/03/25 19:12:37


     541/ 214 : 00                      	DB	0
     541/ 215 : 00                      	DB	0
     541/ 216 : 00                      	DB	0
     541/ 217 : 00                      	DB	0
     541/ 218 : 00                      	DB	0
     543/ 219 :                         tmp_conv_end:
     544/ 219 :                         radix:
     545/ 219 :                         	; used to covert the number for printing
     546/ 219 : 0A                      	DB	10
     547/ 21A :                         prt_buf:
     548/ 21A :                         	; buffer where the converted number is stored for printing
     549/ 21A :                         	REPT	NO_DEC_DIGITS
     550/ 21A :                         	DB	' '
     551/ 21A :                         	ENDM
     550/ 21A : 20                      	DB	' '
     550/ 21B : 20                      	DB	' '
     550/ 21C : 20                      	DB	' '
     550/ 21D : 20                      	DB	' '
     550/ 21E : 20                      	DB	' '
     550/ 21F : 20                      	DB	' '
     550/ 220 : 20                      	DB	' '
     550/ 221 : 20                      	DB	' '
     550/ 222 : 20                      	DB	' '
     550/ 223 : 20                      	DB	' '
     550/ 224 : 20                      	DB	' '
     550/ 225 : 20                      	DB	' '
     550/ 226 : 20                      	DB	' '
     550/ 227 : 20                      	DB	' '
     550/ 228 : 20                      	DB	' '
     550/ 229 : 20                      	DB	' '
     550/ 22A : 20                      	DB	' '
     550/ 22B : 20                      	DB	' '
     550/ 22C : 20                      	DB	' '
     550/ 22D : 20                      	DB	' '
     552/ 22E : 30                      	DB	'0'
     553/ 22F : 00                      	DB	0
     554/ 230 :                         prt_buf_end:
     555/ 230 :                         
     556/ 230 :                         initial_msg:
     557/ 230 : 0D 0A 46 69 62 6F 6E 61 	DB	"\r\nFibonacci numbers that fit into "
          238 : 63 63 69 20 6E 75 6D 62
          240 : 65 72 73 20 74 68 61 74
          248 : 20 66 69 74 20 69 6E 74
          250 : 6F 20                  
     558/ 252 : 36 34                   	DB	BIT_SZ_STR
     559/ 254 : 20 62 69 74 73 0D 0A 00 	DB	" bits\r\n\0"
     560/ 25C :                         final_msg:
     561/ 25C : 0D 0A 50 72 65 73 73 20 	DB	"\r\nPress <ENTER> to return to the monitor\r\n\0"
          264 : 3C 45 4E 54 45 52 3E 20
          26C : 74 6F 20 72 65 74 75 72
          274 : 6E 20 74 6F 20 74 68 65
          27C : 20 6D 6F 6E 69 74 6F 72
          284 : 0D 0A 00               
     562/ 287 :                         
     563/ 287 :                         ; -----------------------------------------------------------------------------
     564/ 287 :                         ; Reserve the space for SCRT stack (R6) from 0x0300 to 0x037F
     565/ 287 :                         ; -----------------------------------------------------------------------------
     566/ 27F :                         	ORG	(code+0x027F)
     567/ 27F :                         scrt_stack:
     568/ 27F :                         
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 16 - 20/03/25 19:12:37


     569/ 27F :                         ; -----------------------------------------------------------------------------
     570/ 27F :                         ; Reserve the space for the standard stack (R2) from 0x0380 to 0x03FF
     571/ 27F :                         ; -----------------------------------------------------------------------------
     572/ 2FF :                         	ORG	(code+0x02FF)
     573/ 2FF :                         stack:
     574/ 2FF :                         
     575/ 2FF :                         
     576/ 2FF :                         ; -----------------------------------------------------------------------------
     577/ 2FF :                         ; Monitor routines called by this program:
     578/ 2FF :                         ; -----------------------------------------------------------------------------
     579/8000 :                         	ORG	0x8000		; monitor entry point
     580/8000 :                         monitor:
     581/8000 :                         
     582/8000 :                         ;	ORG	0x80A3		; mon_get_ch
     583/8000 :                         ;mon_get_ch:
     584/8000 :                         
     585/8000 :                         ;	ORG	0x8100		; mon_put_ch
     586/8000 :                         ;mon_put_ch:
     587/8000 :                         
     588/8519 :                         	ORG	0x8519		; mon_crlf
     589/8519 :                         mon_crlf:
     590/8519 :                         
     591/8519 :                         ;	ORG	0x85BF		; mon_prt_b_hex
     592/8519 :                         ;mon_prt_b_hex:
     593/8519 :                         
     594/8526 :                         	ORG	0x8526		; mon_put_str
     595/8526 :                         mon_put_str:
     596/8526 :                         
     597/8ADB :                         	ORG	0x8ADB		; SCRT call subroutine invoked by SEP R4 and using R6 as SP
     598/8ADB :                         mon_scrt_call:
     599/8ADB :                         
     600/8AED :                         	ORG	0x8AED		; SCRT return subroutine invoked by SEP R5 and using R6 as SP
     601/8AED :                         mon_scrt_return:
     602/8AED :                         
     603/8AED :                         
 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 17 - 20/03/25 19:12:37


  Symbol Table (* = unused):
  --------------------------

*ARCHITECTURE :                                      "x86_64-unknown-linux" - |
*BITFUNCSINC :                    1 - |  BIT_SZ_STR :                  "64" - |
 BYTE_SZ :                        8 - | *CASESENSITIVE :                  0 - |
 CODE :                           0 C | *CONSTPI :     3.141592653589793239 - |
*DATE :                  "20/03/25" - |  DEC_CONV :                     184 C |
 DEC_DIGIT :                    165 C |  DEC_DIGIT_LOOP :               18A C |
 DEC_PREFIX_LESS :              1BD C |  DEC_TEST_IF_DONE :             1C0 C |
*FALSE :                          0 - |  FIB_L :                         4F C |
 FIB_L_END :                    0AF C |  FINAL_MSG :                    25C C |
 FIRST :                        200 C | *FIRST_END :                    208 C |
*FLOATMAX :   1.18973149535725E4932 - | *HAS64 :                          1 - |
 INITIAL_MSG :                  230 C | *LISTON :                         1 - |
*MACEXP :                         7 - |  MAIN :                          21 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                "1802" - |
 MONITOR :                     8000 C |  MON_CRLF :                    8519 C |
 MON_PUT_STR :                 8526 C |  MON_SCRT_CALL :               8ADB C |
 MON_SCRT_RETURN :             8AED C | *NESTMAX :                      100 - |
 NO_DEC_DIGITS :                 14 - |  PRT_BUF :                      21A C |
 PRT_BUF_END :                  230 C |  PRT_NUM :                      0B6 C |
 R0 :                             0 - | *R1 :                             1 - |
 R2 :                             2 - |  R3 :                             3 - |
 R4 :                             4 - |  R5 :                             5 - |
 R6 :                             6 - |  R7 :                             7 - |
 R8 :                             8 - |  R9 :                             9 - |
 RA :                            0A - |  RADIX :                        219 C |
*RB :                            0B - |  RC :                            0C - |
 RD :                            0D - | *RE :                            0E - |
*RELAXED :                        1 - | *RF :                            0F - |
 SCRT_STACK :                   27F C |  SECOND :                       208 C |
*SECOND_END :                   210 C |  STACK :                        2FF C |
*TIME :                  "19:12:37" - |  TMP_CONV :                     210 C |
 TMP_CONV_END :                 219 C | *TRUE :                           1 - |
 VARS :                         200 C | *VERSION :                     142F - |

     65 symbols
     23 unused symbols

 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 18 - 20/03/25 19:12:37


  Defined Macros:
  ---------------

ADD_DP                                |

      1 macro

 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 19 - 20/03/25 19:12:37


  Defined Functions:
  ------------------

ROTRN                                 | ROTLN                                
SHRN                                  | SHLN                                 
GETBIT                                | EVEN                                 
ODD                                   | LOWORD                               
HIWORD                                | LO                                   
HI                                    | CUTOUT                               
INVMASK                               | MASK                                 

 AS V1.42 Beta [Bld 281] - Source File fibonacci.asm - Page 20 - 20/03/25 19:12:37


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.02 seconds assembly time

    684 lines source file
    998 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
