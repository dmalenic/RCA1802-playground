 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 1 - 01/02/25 11:59:34


       1/   0 :                         ; -----------------------------------------------------------------------------
       2/   0 :                         ; SPDX-FileCopyrightText: © 2025 Damir Maleničić,
       3/   0 :                         ; SPDX-License-Identifier: MIT
       4/   0 :                         ; -----------------------------------------------------------------------------
       5/   0 :                         ; 8 Queen Problem
       6/   0 :                         ; The program to find all 92 solutions for the
       7/   0 :                         ; [8 Queen Problem](https://en.wikipedia.org/wiki/Eight_queens_puzzle)
       8/   0 :                         ; and prints them to the connected console.
       9/   0 :                         ; -----------------------------------------------------------------------------
      10/   0 :                         ; The program is written for 1802 Membership Card revision L1 running Chuck
      11/   0 :                         ; Yakym's MS20ANSJ Monitor v2.0JR (10 Jul 2024) located at address 0x8000.
      12/   0 :                         ;
      13/   0 :                         ; It is assembled using
      14/   0 :                         ; [The Macro Assembler AS](http://john.ccac.rwth-aachen.de:8000/as/), but
      15/   0 :                         ; the code should be portable to other 1802 assemblers.
      16/   0 :                         ; The following are the assembling and linking instructions:
      17/   0 :                         ; ```
      18/   0 :                         ; asl -cpu 1802 -L 8-queens.asm
      19/   0 :                         ; p2hex 8-queens.p 8-queens.hex
      20/   0 :                         ; ```
      21/   0 :                         ; -----------------------------------------------------------------------------
      22/   0 :                         ; Register convention imposed by the integration with Chuck's monitor:
      23/   0 :                         ; R0 - reset program counter and SP, PC and SP for user program invoked with
      24/   0 :                         ;      'R' command, DMA memory pointer
      25/   0 :                         ; R1 - interrupt program counter
      26/   0 :                         ; R2 - stack pointer for main and interrupt routines
      27/   0 :                         ; R3 - program counter for main routine
      28/   0 :                         ; R4 - program counter for SCRT subroutine calls
      29/   0 :                         ; R5 - program counter for SCRT subroutine returns
      30/   0 :                         ; R6 - SCRT return address stack
      31/   0 :                         ; R7 - a pointer to a string to be written when invoking 8526
      32/   0 :                         ; RB.HI - holds the input character classification
      33/   0 :                         ; RB.LO - holds the input character, or the output character
      34/   0 :                         ; RE.HI - holds 01
      35/   0 :                         ; RE.LO - holds the baud rate indicator
      36/   0 :                         ; RF.HI - used by SCRT call and return subroutines to preserve the value of D
      37/   0 :                         ;         register between caller and callee
      38/   0 :                         ; -----------------------------------------------------------------------------
      39/   0 :                         ; Monitor routines used by this program (routine names are mine)
      40/   0 :                         ; 8000 - `monitor` entry point
      41/   0 :                         ; 80A3 - `mon_get_ch` reads a character and classifies it as:
      42/   0 :                         ;        00 - CR, 1 - space, 02 - ESC, 03 - digit, 04 - hex-letter or FF - other
      43/   0 :                         ; 8526 - `mon_put_str` writes a string to the screen. R7 points to the string.
      44/   0 :                         ;        R7 is preserved after the call.
      45/   0 :                         ; 8ADB - SCRT call a subroutine (invoked with R4 as PC)
      46/   0 :                         ; 8AED - SCRT return from a subroutine (invoked with R5 as PC)
      47/   0 :                         ; -----------------------------------------------------------------------------
      48/   0 :                         
      49/   0 :                         
      50/   0 :                         ; enable C style numeric constants --------------------------------------------
      51/   0 :                         
      52/   0 :                         
      53/   0 :                         	RELAXED	ON
      54/   0 :                         
      55/   0 :                         	CPU	1802
      56/   0 :                         
      57/   0 :                         
      58/   0 :                         ; include the bit manipulation functions --------------------------------------
      59/   0 :                         ; This file defines a couple of bit-oriented functions that might be hardwired
      60/   0 :                         ; when using other assemblers.
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 2 - 01/02/25 11:59:34


      61/   0 :                         ; A code uses `hi()` and `lo()` operators that `asl` implements as user-defined
      62/   0 :                         ; function. $ is the synonym for the current PC address.
      63/   0 :                         ; The source for `bitfuncs.inc` is provided to help port those functions to the
      64/   0 :                         ; assembler of your choice.
      65/   0 :                         
      66/   0 :                         
      67/   0 :                         	INCLUDE "bitfuncs.inc"
(1)    1/   0 : =>UNDEFINED             		ifndef   bitfuncsinc    ; avoid multiple inclusion
(1)    2/   0 : =1H                     bitfuncsinc     equ      1
(1)    3/   0 :                         
(1)    4/   0 :                                         save
(1)   77/   0 : ALL                                     restore                 ; allow listing again
(1)   78/   0 :                         
(1)   79/   0 : [1]                                     endif			; bitfuncsinc
(1)   80/   0 :                         
(1)   81/   0 :                         
      68/   0 :                         
      69/   0 :                         
      70/   0 :                         ; register aliases ------------------------------------------------------------
      71/   0 : =0H                     R0	EQU	0
      72/   0 : =1H                     R1	EQU	1
      73/   0 : =2H                     R2	EQU	2
      74/   0 : =3H                     R3	EQU	3
      75/   0 : =4H                     R4	EQU	4
      76/   0 : =5H                     R5	EQU	5
      77/   0 : =6H                     R6	EQU	6
      78/   0 : =7H                     R7	EQU	7
      79/   0 : =8H                     R8	EQU	8
      80/   0 : =9H                     R9	EQU	9
      81/   0 : =0AH                    RA	EQU	10
      82/   0 : =0BH                    RB	EQU	11
      83/   0 : =0CH                    RC	EQU	12
      84/   0 : =0DH                    RD	EQU	13
      85/   0 : =0EH                    RE	EQU	14
      86/   0 : =0FH                    RF	EQU	15
      87/   0 :                         
      88/   0 :                         
      89/   0 :                         	ORG	0
      90/   0 :                         code:
      91/   0 :                         
      92/   0 :                         	; -----------------------------------------------------------------------------
      93/   0 :                         	; Initialize the program
      94/   0 :                         	; -----------------------------------------------------------------------------
      95/   0 :                         	; When started after reset, or by executing the monitor R0000 command:
      96/   0 :                         	; R0 is set to be both the program counter and the stack pointer
      97/   0 :                         	; R1 is  pointer.
      98/   0 :                         	; R2 is will become stack pointer in a case of an interrupt
      99/   0 :                         	; Following section configures the registers:
     100/   0 :                         	; R2 to point to the area that will become a stack pointer when control is passed to main
     101/   0 :                         	; R3 to point to main, it will become a program counter
     102/   0 :                         	; R4 will point to SCRT call routine
     103/   0 :                         	; R5 will point to SCRT return routine
     104/   0 :                         	; R6 will point to SCRT stack
     105/   0 :                         	; -----------------------------------------------------------------------------
     106/   0 :                         start:
     107/   0 :                         	; initialize R4 to 0x8ADB and R5 to 0x8AED to enable SCRT
     108/   0 : F8 8A                   	LDI	hi(mon_scrt_call)
     109/   2 : B4                      	PHI	R4
     110/   3 : B5                      	PHI	R5
     111/   4 : F8 DB                   	LDI	lo(mon_scrt_call)
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 3 - 01/02/25 11:59:34


     112/   6 : A4                      	PLO	R4
     113/   7 : F8 ED                   	LDI	lo(mon_scrt_return)
     114/   9 : A5                      	PLO	R5
     115/   A :                         
     116/   A :                         	; initialize R6 to SCRT_stack
     117/   A : F8 03                   	LDI	hi(scrt_stack)
     118/   C : B6                      	PHI	R6
     119/   D : F8 7F                   	LDI	lo(scrt_stack)
     120/   F : A6                      	PLO	R6
     121/  10 :                         
     122/  10 :                         	; configure R3 to point to the main
     123/  10 : F8 21                   	LDI	lo(main)
     124/  12 : A3                      	PLO	R3
     125/  13 : 90                      	GHI	R0
     126/  14 : B3                      	PHI	R3
     127/  15 :                         
     128/  15 :                         	; configure R2 to point to the stack
     129/  15 : F8 03                   	LDI	hi(stack)
     130/  17 : B2                      	PHI	R2
     131/  18 : F8 FF                   	LDI	lo(stack)
     132/  1A : A2                      	PLO	R2
     133/  1B :                         
     134/  1B :                         	; pass the control to main
     135/  1B : E2                      	SEX	R2			; Make R2 the default index register i.e. stack pointer
     136/  1C : D3                      	SEP	R3			; this will call main, while R0 still
     137/  1D :                         
     138/  1D :                         	; -----------------------------------------------------------------------------
     139/  1D :                         	; The program exit point
     140/  1D :                         	; -----------------------------------------------------------------------------
     141/  1D :                         	; R0 is pointing to this location so when SEP 0 is executed at the end of main,
     142/  1D :                         	; the program execution will resume at this point
     143/  1D : E0                      	SEX	R0			; Make R0 default index register like on reset
     144/  1E : C0 80 00                	LBR	monitor			; jump to monitor
     145/  21 :                         
     146/  21 :                         	; -----------------------------------------------------------------------------
     147/  21 :                         	; The main routine
     148/  21 :                         	; -----------------------------------------------------------------------------
     149/  21 :                         main:
     150/  21 :                         	; initialize
     151/  21 : F8 02                   	LDI	hi(rows)		; get address of the first row
     152/  23 : B8                      	PHI	R8			; initialize page address for all variable pointers
     153/  24 : F8 00                   	LDI	lo(rows)		; get address of the first row
     154/  26 : A8                      	PLO	R8			; R8 points to the first row
     155/  27 :                         
     156/  27 :                         	; set the initial values for the first recursive call
     157/  27 : F8 80                   	LDI	0x80			; initial cell of the first row
     158/  29 : 58                      	STR	R8			; store it to the memory
     159/  2A : F8 08                   	LDI	8			; number of rows to process
     160/  2C : BA                      	PHI	RA			; store it to RA.HI
     161/  2D : F8 00                   	LDI	0			; the first row is the current row
     162/  2F : AA                      	PLO	RA			; RA.LO holds the current row
     163/  30 :                         
     164/  30 :                         	; call the recursive routine to find 8-queen positions
     165/  30 : D4                      	SEP	R4
     166/  31 : 00                      	DB	hi(find_pos)
     167/  32 : 39                      	DB	lo(find_pos)
     168/  33 :                         
     169/  33 :                         	; no_more_solutions or user has cancelled the process, print the appropriate
     170/  33 :                         	; message to ask a user to press <ENTER> to return to monitor
     171/  33 :                         no_more_solutions:
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 4 - 01/02/25 11:59:34


     172/  33 : D4                      	SEP	R4
     173/  34 : 01                      	DB	hi(put_str)
     174/  35 : 8A                      	DB	lo(put_str)
     175/  36 : 02                      	DB	hi(no_more_sols)
     176/  37 : 44                      	DB	lo(no_more_sols)
     177/  38 :                         
     178/  38 :                         	; -----------------------------------------------------------------------------
     179/  38 :                         	; return the control to the program exit point
     180/  38 :                         	; -----------------------------------------------------------------------------
     181/  38 : D0                      	SEP	R0
     182/  39 :                         
     183/  39 :                         
     184/  39 :                         	; -----------------------------------------------------------------------------
     185/  39 :                         	; Find position
     186/  39 :                         	; -----------------------------------------------------------------------------
     187/  39 :                         	; Routine specific register usage:
     188/  39 :                         	; Input:
     189/  39 :                         	; R8 - points to current row representation
     190/  39 :                         	; RA.HI - holds number of rows to process
     191/  39 :                         	; RA.LO - the current row index
     192/  39 :                         	; RB - user interaction
     193/  39 :                         	; Output:
     194/  39 :                         	; RF.LO - 1 if position found, 0 if not
     195/  39 :                         	; -----------------------------------------------------------------------------
     196/  39 :                         find_pos:
     197/  39 :                         	; test if all 8 rows have been successfully processed?
     198/  39 : 8A                      	GLO	RA			; get current row value and check if it is 8?
     199/  3A : FD 08                   	SDI	8			; D = 8 - D i.e. will be 0 if all rows are processed
     200/  3C : 3A 53                   	BNZ	find_pos_proc_row	; if it is not the last row, continue processing current row
     201/  3E :                         
     202/  3E :                         	; last row processed - print the solution
     203/  3E : D4                      	SEP	R4
     204/  3F : 01                      	DB	hi(print_board)
     205/  40 : 00                      	DB	lo(print_board)
     206/  41 :                         
     207/  41 :                         	; inform and ask a user to press <ENTER> to look for the next solution or <ESC> to return to monitor
     208/  41 :                         find_user_response:
     209/  41 :                         	; write message to the user
     210/  41 : D4                      	SEP	R4
     211/  42 : 01                      	DB	hi(put_str)
     212/  43 : 8A                      	DB	lo(put_str)
     213/  44 : 02                      	DB	hi(next_or_exit)
     214/  45 : 85                      	DB	lo(next_or_exit)
     215/  46 :                         
     216/  46 :                         	; read user's response, on return, RB.HI will be 0 for <ENTER> or 2 for <ESC>
     217/  46 : D4                      	SEP	R4
     218/  47 : 80                      	DB	hi(mon_get_ch)
     219/  48 : A3                      	DB	lo(mon_get_ch)
     220/  49 :                         
     221/  49 :                         	; check if <ENTER>
     222/  49 : 9B                      	GHI	RB			; RB.HI is 0 if user pressed <ENTER>
     223/  4A : 32 74                   	BZ	find_pos_ret		; return to the previous level look for the next solution
     224/  4C :                         
     225/  4C :                         	; check if <ESC>
     226/  4C : FF 02                   	SMI	2			; if ESC was pressed RB.HI
     227/  4E : 3A 41                   	BNZ	find_user_response	; not the <ESC> key, invalid input let user try again
     228/  50 : C0 00 33                	LBR	no_more_solutions	; drop from all recursive calls and return to monitor
     229/  53 :                         
     230/  53 :                         	; process current row
     231/  53 :                         find_pos_proc_row:
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 5 - 01/02/25 11:59:34


     232/  53 :                         	; check if the queen at current position in the current row is attacking any other queen
     233/  53 : D4                      	SEP	R4			; test if attacking a queen in the same column
     234/  54 : 00                      	DB	hi(test_col)
     235/  55 : 75                      	DB	lo(test_col)
     236/  56 : 8F                      	GLO	RF
     237/  57 : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     238/  59 : D4                      	SEP	R4			; test if attacking a queen in the up-left diagonal
     239/  5A : 00                      	DB	hi(test_left_diag)
     240/  5B : 9A                      	DB	lo(test_left_diag)
     241/  5C : 8F                      	GLO	RF
     242/  5D : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     243/  5F : D4                      	SEP	R4			; test if attacking a queen in the up-right diagonal
     244/  60 : 00                      	DB	hi(test_right_diag)
     245/  61 : C6                      	DB	lo(test_right_diag)
     246/  62 : 8F                      	GLO	RF
     247/  63 : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     248/  65 :                         
     249/  65 :                         	; no - found a safe position for the current row, move to next row recursively
     250/  65 : 18                      	INC	R8			; move the current row state pointer to the next row
     251/  66 : F8 80                   	LDI	0x80			; define the initial state for the next row
     252/  68 : 58                      	STR	R8			; and store it
     253/  69 : 1A                      	INC	RA			; increase the current row indicator
     254/  6A : D4                      	SEP	R4			; call recursively the routine to find the valid position in a new row
     255/  6B : 00                      	DB	hi(find_pos)
     256/  6C : 39                      	DB	lo(find_pos)
     257/  6D : 2A                      	DEC	RA			; on return restore the current row indicator
     258/  6E : 28                      	DEC	R8			; and restore the pointer to current row state
     259/  6F :                         
     260/  6F :                         	; try the next position in the current row if the current row is not exhausted
     261/  6F :                         find_next_pos_in_row:
     262/  6F : 08                      	LDN	R8			; get row state
     263/  70 : F6                      	SHR				; next row state
     264/  71 : 58                      	STR	R8			; save new row state
     265/  72 : 3B 53                   	BNF	find_pos_proc_row	; if it is not 0 after rotation, the stat is valid and loop to test it
     266/  74 :                         	; otherwise return back to the previous row
     267/  74 :                         
     268/  74 :                         find_pos_ret:
     269/  74 : D5                      	SEP	R5			; return from the subroutine
     270/  75 :                         
     271/  75 :                         
     272/  75 :                         	; ---------------------------------------------------------------------
     273/  75 :                         	; Test if attacking any other queen in the current column
     274/  75 :                         	; ---------------------------------------------------------------------
     275/  75 :                         	; Routine specific register usage:
     276/  75 :                         	; Input:
     277/  75 :                         	; R8 - points to current state row representation
     278/  75 :                         	; RA.LO - indicates the current row number
     279/  75 :                         	; Output:
     280/  75 :                         	; RF.LO - 1 if not attacking any other queen in the current column, 0 otherwise
     281/  75 :                         	; Internal usage (values preserved):
     282/  75 :                         	; RA.HI - the working copy of the the test mask
     283/  75 :                         	; R8 - points to row we test against
     284/  75 :                         	; D and DF are not preserved
     285/  75 :                         	; ---------------------------------------------------------------------
     286/  75 :                         test_col:
     287/  75 :                         	; save the registers that may be modified
     288/  75 : 9A                      	GHI	RA			; save RA on stack
     289/  76 : 73                      	STXD
     290/  77 : 8A                      	GLO	RA
     291/  78 : 73                      	STXD
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 6 - 01/02/25 11:59:34


     292/  79 : 98                      	GHI	R8			; save R8 on stack
     293/  7A : 73                      	STXD
     294/  7B : 88                      	GLO	R8
     295/  7C : 73                      	STXD
     296/  7D :                         
     297/  7D :                         	; initialize the test
     298/  7D : E8                      	SEX	R8			; make R8 a temporary SP
     299/  7E : F8 01                   	LDI	1			; assume the positive result
     300/  80 : AF                      	PLO	RF
     301/  81 : 08                      	LDN	R8			; take the current row state
     302/  82 : BA                      	PHI	RA			; preserve it in RA.HI as the test mask
     303/  83 :                         
     304/  83 :                         	; testing loop
     305/  83 :                         test_col_loop:
     306/  83 : 8A                      	GLO	RA			; are we in the top row?
     307/  84 : 32 8F                   	BZ	test_col_ret		; yes, then we are done
     308/  86 : 28                      	DEC	R8			; otherwise point to the previous row
     309/  87 : 2A                      	DEC	RA			; decrease testing row counter
     310/  88 : 9A                      	GHI	RA			; get the test mask
     311/  89 : F2                      	AND				; check if it overlaps with the testing row state
     312/  8A : 32 83                   	BZ	test_col_loop		; no, proceed to test with the row above
     313/  8C : F8 00                   	LDI	0			; yes, the test has failed
     314/  8E : AF                      	PLO	RF			; so indicate the negative result in the return value
     315/  8F :                         
     316/  8F :                         	; restore to the state before the call
     317/  8F :                         test_col_ret:
     318/  8F : E2                      	SEX	R2			; restore the stack pointer to R2
     319/  90 : 60                      	IRX				; drop SP to point the saved registers
     320/  91 : 72                      	LDXA				; restore R8
     321/  92 : A8                      	PLO	R8
     322/  93 : 72                      	LDXA
     323/  94 : B8                      	PHI	R8
     324/  95 : 72                      	LDXA				; restore RA
     325/  96 : AA                      	PLO	RA
     326/  97 : F0                      	LDX
     327/  98 : BA                      	PHI	RA
     328/  99 : D5                      	SEP	R5			; return
     329/  9A :                         
     330/  9A :                         
     331/  9A :                         	; ---------------------------------------------------------------------
     332/  9A :                         	; Test if attacking any other queen in the up-left diagonal
     333/  9A :                         	; ---------------------------------------------------------------------
     334/  9A :                         	; Routine specific register usage:
     335/  9A :                         	; Input:
     336/  9A :                         	; R8 - points to current state row representation
     337/  9A :                         	; RA.LO - indicates the current row number
     338/  9A :                         	; Output:
     339/  9A :                         	; RF.LO - 1 if not attacking any other queen in the diagonal, 0 otherwise
     340/  9A :                         	; Internal usage (values preserved):
     341/  9A :                         	; RA.HI - the working copy of the the test mask
     342/  9A :                         	; R8 - points to row we test against
     343/  9A :                         	; D and DF are not preserved
     344/  9A :                         	; ---------------------------------------------------------------------
     345/  9A :                         test_left_diag:
     346/  9A :                         	; save the registers that may be modified
     347/  9A : 9A                      	GHI	RA			; save RA on stack
     348/  9B : 73                      	STXD
     349/  9C : 8A                      	GLO	RA
     350/  9D : 73                      	STXD
     351/  9E : 98                      	GHI	R8			; save R8 on stack
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 7 - 01/02/25 11:59:34


     352/  9F : 73                      	STXD
     353/  A0 : 88                      	GLO	R8
     354/  A1 : 73                      	STXD
     355/  A2 :                         
     356/  A2 :                         	; initialize the test
     357/  A2 : E8                      	SEX	R8			; make R8 a temporary SP
     358/  A3 : F8 00                   	LDI	0			; make sure DF is 0 so we test only one position per row
     359/  A5 : FE                      	SHL
     360/  A6 : F8 01                   	LDI	1			; assume the positive result
     361/  A8 : AF                      	PLO	RF
     362/  A9 : 08                      	LDN	R8			; take current row state
     363/  AA : BA                      	PHI	RA			; preserve it in RA.HI as the initial test mask
     364/  AB :                         
     365/  AB :                         	; testing loop
     366/  AB :                         test_left_diag_loop:
     367/  AB : 8A                      	GLO	RA			; are we in the top row?
     368/  AC : 32 BB                   	BZ	test_left_diag_ret	; yes, then we are done
     369/  AE : 28                      	DEC	R8			; no, point to the previous row
     370/  AF : 2A                      	DEC	RA			; decrease testing row counter
     371/  B0 : 9A                      	GHI	RA			; get the test mask
     372/  B1 : FE                      	SHL				; shift mask left
     373/  B2 : 33 BB                   	BDF	test_left_diag_ret	; if shifted out of the board we are done
     374/  B4 : BA                      	PHI	RA			; preserve the test maks for the next iteration
     375/  B5 : F2                      	AND				; check if it overlaps with the testing row state
     376/  B6 : 32 AB                   	BZ	test_left_diag_loop	; no, proceed to test with the row above
     377/  B8 : F8 00                   	LDI	0			; yes, the test has failed
     378/  BA : AF                      	PLO	RF			; so indicate the negative result in the return value
     379/  BB :                         
     380/  BB :                         test_left_diag_ret:
     381/  BB :                         	; restore to the state before the call
     382/  BB : E2                      	SEX	R2			; restore the stack pointer
     383/  BC : 60                      	IRX				; drop SP to point the saved registers
     384/  BD : 72                      	LDXA				; restore R8
     385/  BE : A8                      	PLO	R8
     386/  BF : 72                      	LDXA
     387/  C0 : B8                      	PHI	R8
     388/  C1 : 72                      	LDXA				; restore RA
     389/  C2 : AA                      	PLO	RA
     390/  C3 : F0                      	LDX
     391/  C4 : BA                      	PHI	RA
     392/  C5 : D5                      	SEP	R5			; return
     393/  C6 :                         
     394/  C6 :                         
     395/  C6 :                         	; ---------------------------------------------------------------------
     396/  C6 :                         	; Test if attacking any other queen in the up-right diagonal
     397/  C6 :                         	; ---------------------------------------------------------------------
     398/  C6 :                         	; Routine specific register usage:
     399/  C6 :                         	; Input:
     400/  C6 :                         	; R8 - points to current state row representation
     401/  C6 :                         	; RA.LO - indicates the current row number
     402/  C6 :                         	; Output:
     403/  C6 :                         	; RF.LO - 1 if not attacking any other queen in the diagonal, 0 otherwise
     404/  C6 :                         	; Internal usage (values preserved):
     405/  C6 :                         	; RA.HI - the working copy of the the test mask
     406/  C6 :                         	; R8 - points to row we test against
     407/  C6 :                         	; D and DF are not preserved
     408/  C6 :                         	; ---------------------------------------------------------------------
     409/  C6 :                         test_right_diag:
     410/  C6 : 9A                      	GHI	RA			; save RA on stack
     411/  C7 : 73                      	STXD
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 8 - 01/02/25 11:59:34


     412/  C8 : 8A                      	GLO	RA
     413/  C9 : 73                      	STXD
     414/  CA : 98                      	GHI	R8			; save R8 on stack
     415/  CB : 73                      	STXD
     416/  CC : 88                      	GLO	R8
     417/  CD : 73                      	STXD
     418/  CE :                         
     419/  CE :                         	; initialize the test
     420/  CE : E8                      	SEX	R8			; make R8 a temporary SP
     421/  CF : F8 00                   	LDI	0			; make sure DF is 0 so we test only one position per row
     422/  D1 : F6                      	SHR
     423/  D2 : F8 01                   	LDI	1			; assume the positive result
     424/  D4 : AF                      	PLO	RF
     425/  D5 : 08                      	LDN	R8			; take current row state
     426/  D6 : BA                      	PHI	RA			; preserve it in RA.HI as the initial test mask
     427/  D7 :                         
     428/  D7 :                         	; testing loop
     429/  D7 :                         test_right_diag_loop:
     430/  D7 : 8A                      	GLO	RA			; are we in the top row?
     431/  D8 : 32 E7                   	BZ	test_right_diag_ret	; yes, then we are done
     432/  DA : 28                      	DEC	R8			; no, point to the previous row
     433/  DB : 2A                      	DEC	RA			; decrease testing row counter
     434/  DC : 9A                      	GHI	RA			; get the test mask
     435/  DD : F6                      	SHR				; shift mask right
     436/  DE : 33 E7                   	BDF	test_right_diag_ret	; if shifted out of board we are done
     437/  E0 : BA                      	PHI	RA			; preserve the test maks for the next iteration
     438/  E1 : F2                      	AND				; check if it overlaps with the testing row state
     439/  E2 : 32 D7                   	BZ	test_right_diag_loop	; no, proceed to test with the row above
     440/  E4 : F8 00                   	LDI	0			; yes, the test has failed
     441/  E6 : AF                      	PLO	RF			; so indicate the negative result in the return value
     442/  E7 :                         
     443/  E7 :                         test_right_diag_ret:
     444/  E7 :                         	; restore to the state before the call
     445/  E7 : E2                      	SEX	R2			; restore the stack pointer
     446/  E8 : 60                      	IRX				; drop SP to point the saved registers
     447/  E9 : 72                      	LDXA				; restore R8
     448/  EA : A8                      	PLO	R8
     449/  EB : 72                      	LDXA
     450/  EC : B8                      	PHI	R8
     451/  ED : 72                      	LDXA				; restore RA
     452/  EE : AA                      	PLO	RA
     453/  EF : F0                      	LDX
     454/  F0 : BA                      	PHI	RA
     455/  F1 : D5                      	SEP	R5			; return
     456/  F2 :                         
     457/  F2 :                         
     458/ 100 :                         	ORG	0x0100
     459/ 100 :                         
     460/ 100 :                         	; -----------------------------------------------------------------------------
     461/ 100 :                         	; Print the result
     462/ 100 :                         	; -----------------------------------------------------------------------------
     463/ 100 :                         	; Routine specific register usage:
     464/ 100 :                         	; Input registers: none
     465/ 100 :                         	; Output registers: none
     466/ 100 :                         	; Internal usage (values preserved):
     467/ 100 :                         	; R8 - points to the current row
     468/ 100 :                         	; R9.LO - the working copy of the current chessboard row content
     469/ 100 :                         	; RA.HI - the number of rows to print
     470/ 100 :                         	; D and DF are not preserved
     471/ 100 :                         	; -----------------------------------------------------------------------------
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 9 - 01/02/25 11:59:34


     472/ 100 :                         print_board:
     473/ 100 :                         	; preserve R8, R9.LO, RA.HI
     474/ 100 : 98                      	GHI	R8
     475/ 101 : 73                      	STXD
     476/ 102 : 88                      	GLO	R8
     477/ 103 : 73                      	STXD
     478/ 104 : 89                      	GLO	R9
     479/ 105 : 73                      	STXD
     480/ 106 : 8A                      	GLO	RA
     481/ 107 : 73                      	STXD
     482/ 108 :                         
     483/ 108 :                         	; initialize printing
     484/ 108 : F8 08                   	LDI	8			; number or chessboard rows to print
     485/ 10A : BA                      	PHI	RA			; store it to RA.HI
     486/ 10B : F8 02                   	LDI	hi(rows)		; get address of the first row
     487/ 10D : B8                      	PHI	R8
     488/ 10E : F8 00                   	LDI	lo(rows)
     489/ 110 : A8                      	PLO	R8			; R8 points to the first row
     490/ 111 :                         
     491/ 111 :                         	; print the header row
     492/ 111 : D4                      	SEP	R4
     493/ 112 : 01                      	DB	hi(put_str)
     494/ 113 : 8A                      	DB	lo(put_str)
     495/ 114 : 02                      	DB	hi(hdr_row)
     496/ 115 : 23                      	DB	lo(hdr_row)
     497/ 116 :                         
     498/ 116 :                         	; the row printing loop
     499/ 116 :                         print_row:
     500/ 116 :                         	; print a current row content
     501/ 116 : D4                      	SEP	R4			; print row, on return R8 will point to the next row
     502/ 117 : 01                      	DB	hi(print_current_row)
     503/ 118 : 29                      	DB	lo(print_current_row)
     504/ 119 : 9A                      	GHI	RA			; get the number of rows to process
     505/ 11A : FF 01                   	SMI	1			; decrease it
     506/ 11C : BA                      	PHI	RA			; preserve the value
     507/ 11D : 3A 16                   	BNZ	print_row		; if it is no 0 continue with the next row
     508/ 11F :                         
     509/ 11F :                         	; restore RA.LO, R9.LO, R8
     510/ 11F : 60                      	IRX				; drop SP to point the saved registers
     511/ 120 : 72                      	LDXA
     512/ 121 : AA                      	PLO	RA
     513/ 122 : 72                      	LDXA
     514/ 123 : A9                      	PLO	R9
     515/ 124 : 72                      	LDXA
     516/ 125 : A8                      	PLO	R8
     517/ 126 : F0                      	LDX
     518/ 127 : B8                      	PHI	R8
     519/ 128 :                         	; return
     520/ 128 : D5                      	SEP	R5
     521/ 129 :                         
     522/ 129 :                         
     523/ 129 :                         	; -----------------------------------------------------------------------------
     524/ 129 :                         	; Print current chessboard row
     525/ 129 :                         	; -----------------------------------------------------------------------------
     526/ 129 :                         	; Routine specific register usage:
     527/ 129 :                         	; Input:
     528/ 129 :                         	; R8 - points to the current row
     529/ 129 :                         	; Output:
     530/ 129 :                         	; R8 - points to the next row
     531/ 129 :                         	; Internal usage (values preserved):
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 10 - 01/02/25 11:59:34


     532/ 129 :                         	; R7 - points to a string to be printed using monitor routine at 0x8526
     533/ 129 :                         	; R9.HI - the number of (remaining) chessboard fields in the current row to print
     534/ 129 :                         	; R9.LO - working copy of the current row content
     535/ 129 :                         	; RA.LO - indicator if the current print is black or white
     536/ 129 :                         	; RB.LO - a character to print using `mon_put_ch`
     537/ 129 :                         	; -----------------------------------------------------------------------------
     538/ 129 :                         print_current_row:
     539/ 129 :                         	; preserve R7, R9, RA.LO, RB.LO
     540/ 129 : 97                      	GHI	R7
     541/ 12A : 73                      	STXD
     542/ 12B : 87                      	GLO	R7
     543/ 12C : 73                      	STXD
     544/ 12D : 99                      	GHI	R9
     545/ 12E : 73                      	STXD
     546/ 12F : 89                      	GLO	R9
     547/ 130 : 73                      	STXD
     548/ 131 : 8A                      	GLO	RA
     549/ 132 : 73                      	STXD
     550/ 133 : 8B                      	GLO	RB
     551/ 134 : 73                      	STXD
     552/ 135 :                         
     553/ 135 :                         	; print row number
     554/ 135 : 9A                      	GHI	RA		; load remaining number of rows to print into D
     555/ 136 : FD 39                   	SDI	'9'		; D = '9' - D, subtract current row number from '9'
     556/ 138 : AB                      	PLO	RB		; put result in RB.LO for printing
     557/ 139 : D4                      	SEP	R4		; invoke mon_put_ch routine to print the character in RB.LO
     558/ 13A : 81                      	DB	hi(mon_put_ch)
     559/ 13B : 00                      	DB	lo(mon_put_ch)
     560/ 13C :                         
     561/ 13C :                         	; print a space between the row number and the first field
     562/ 13C : D4                      	SEP	R4
     563/ 13D : 01                      	DB	hi(put_str)
     564/ 13E : 8A                      	DB	lo(put_str)
     565/ 13F : 02                      	DB	hi(row_start)
     566/ 140 : 3F                      	DB	lo(row_start)
     567/ 141 :                         
     568/ 141 :                         	; initialize the field counter, row pointer, black-white indicator
     569/ 141 : F8 08                   	LDI	8	; 8 chessboard fields in a row
     570/ 143 : B9                      	PHI	R9	; R9.HI holds a number of chessboard fields in a row to print
     571/ 144 : 48                      	LDA	R8	; Load content of the current row then make R8 points to the next row
     572/ 145 : A9                      	PLO	R9	; R9.LO holds ca working copy of the current row
     573/ 146 : 88                      	GLO	R8	; Test if it is an odd or an even row? The odd rows start with a white cell.
     574/ 147 : FA 01                   	ANI	01	; Is it even or odd row?
     575/ 149 : AA                      	PLO	RA	; Store this info in RA.LO so we can invert it for the next iteration
     576/ 14A : 32 51                   	BZ	print_current_field	; If it is an even row skip sending invert video esc sequence
     577/ 14C :                         
     578/ 14C :                         	; print invert video escape sequence
     579/ 14C :                         print_esc_inv:
     580/ 14C : D4                      	SEP	R4
     581/ 14D : 01                      	DB	hi(put_str)
     582/ 14E : 8A                      	DB	lo(put_str)
     583/ 14F : 02                      	DB	hi(esc_inv)
     584/ 150 : 09                      	DB	lo(esc_inv)
     585/ 151 :                         
     586/ 151 :                         	; print the current field
     587/ 151 :                         print_current_field:
     588/ 151 :                         	; load page holding strings representing board content to R7.HI, R7.LO will depend on content to print
     589/ 151 : F8 02                   	LDI	hi(field)
     590/ 153 : B7                      	PHI	R7
     591/ 154 :                         
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 11 - 01/02/25 11:59:34


     592/ 154 :                         	; determine the current field content depending if the corresponding row bit is 1 (a queen) or 0 (an empty field)
     593/ 154 : 89                      	GLO	R9		; get the working copy of the current row
     594/ 155 : FE                      	SHL			; shift D left putting msb in the DF
     595/ 156 : A9                      	PLO	R9		; store the new state of the working copy of the current row for the next iteration
     596/ 157 : 33 5E                   	BDF	print_queen	; if the DF is 1 the field contains the queen
     597/ 159 :                         
     598/ 159 :                         	; get string representing an empty field into R7
     599/ 159 : F8 1F                   	LDI	lo(field)
     600/ 15B : A7                      	PLO	R7
     601/ 15C : 30 61                   	BR	print_field_content
     602/ 15E :                         
     603/ 15E :                         	; get string representing a field with queen into R7
     604/ 15E :                         print_queen:
     605/ 15E : F8 13                   	LDI	lo(queen)
     606/ 160 : A7                      	PLO	R7
     607/ 161 :                         
     608/ 161 :                         	; print the current field
     609/ 161 :                         print_field_content:
     610/ 161 : D4                      	SEP	R4
     611/ 162 : 85                      	DB	hi(mon_put_str)
     612/ 163 : 26                      	DB	lo(mon_put_str)
     613/ 164 :                         
     614/ 164 :                         	; undo the inverse video and bold-face font if either or both were set by printing norm esc sequence
     615/ 164 : D4                      	SEP	R4
     616/ 165 : 01                      	DB	hi(put_str)
     617/ 166 : 8A                      	DB	lo(put_str)
     618/ 167 : 02                      	DB	hi(esc_norm)
     619/ 168 : 0E                      	DB	lo(esc_norm)
     620/ 169 :                         
     621/ 169 :                         	; prepare for printing the next field
     622/ 169 :                         print_next_field:
     623/ 169 : 99                      	GHI	R9		; get the number of fields to print in the current row
     624/ 16A : FF 01                   	SMI	1		; decrease it
     625/ 16C : 32 77                   	BZ	print_crlf_and_ret	; if the result is 0 print <CR><LF> and return
     626/ 16E : B9                      	PHI	R9		; otherwise preserve the number of fields left to print for the next iteration
     627/ 16F : 8A                      	GLO	RA		; get the black-white field indicator
     628/ 170 : FB 01                   	XRI	1		; invert it
     629/ 172 : AA                      	PLO	RA		; and preserve the result for the next iteration
     630/ 173 : 32 51                   	BZ	print_current_field	; if it was black go to directly printing a field content
     631/ 175 : 30 4C                   	BR	print_esc_inv	; if it was white, go to printing video invert esc sequence first
     632/ 177 :                         
     633/ 177 :                         	; print <CR><LF> sequence
     634/ 177 :                         print_crlf_and_ret:
     635/ 177 : D4                      	SEP	R4
     636/ 178 : 01                      	DB	hi(put_str)
     637/ 179 : 8A                      	DB	lo(put_str)
     638/ 17A : 02                      	DB	hi(row_end)
     639/ 17B : 41                      	DB	lo(row_end)
     640/ 17C :                         
     641/ 17C :                         	; restore RB.LO, RA.LO, R9, R7
     642/ 17C : 60                      	IRX
     643/ 17D : 72                      	LDXA
     644/ 17E : AB                      	PLO	RB
     645/ 17F : 72                      	LDXA
     646/ 180 : AA                      	PLO	RA
     647/ 181 : 72                      	LDXA
     648/ 182 : A9                      	PLO	R9
     649/ 183 : 72                      	LDXA
     650/ 184 : B9                      	PHI	R9
     651/ 185 : 72                      	LDXA
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 12 - 01/02/25 11:59:34


     652/ 186 : A7                      	PLO	R7
     653/ 187 : F0                      	LDX
     654/ 188 : B7                      	PHI	R7
     655/ 189 :                         	; return
     656/ 189 : D5                      	SEP	R5
     657/ 18A :                         
     658/ 18A :                         
     659/ 18A :                         	; -----------------------------------------------------------------------------
     660/ 18A :                         	; The wrapper for `mon_put_str` to enable passing string address inline with
     661/ 18A :                         	; a subroutine call
     662/ 18A :                         	; -----------------------------------------------------------------------------
     663/ 18A :                         	; Internal usage (values preserved):
     664/ 18A :                         	; R7 - hold pointer to the string when invoking the `mon_put_str` routine
     665/ 18A :                         	; -----------------------------------------------------------------------------
     666/ 18A :                         put_str:
     667/ 18A :                         	; preserve R7 register
     668/ 18A : 97                      	GHI	R7
     669/ 18B : 73                      	STXD
     670/ 18C : 87                      	GLO	R7
     671/ 18D : 73                      	STXD
     672/ 18E :                         
     673/ 18E :                         	; load inline string address into R7
     674/ 18E : 46                      	LDA	R6
     675/ 18F : B7                      	PHI	R7
     676/ 190 : 46                      	LDA	R6
     677/ 191 : A7                      	PLO	R7
     678/ 192 :                         
     679/ 192 :                         	; call mon_put_str routine from the monitor that expects R7 to point to the string
     680/ 192 : D4                      	SEP	R4
     681/ 193 : 85                      	DB	hi(mon_put_str)
     682/ 194 : 26                      	DB	lo(mon_put_str)
     683/ 195 :                         
     684/ 195 :                         	; restore R7 register
     685/ 195 : 60                      	IRX
     686/ 196 : 72                      	LDXA
     687/ 197 : A7                      	PLO	R7
     688/ 198 : F0                      	LDX
     689/ 199 : B7                      	PHI	R7
     690/ 19A :                         	; return
     691/ 19A : D5                      	SEP	R5
     692/ 19B :                         
     693/ 19B :                         
     694/ 200 :                         		ORG	(code+0x0200)
     695/ 200 :                         vars:
     696/ 200 :                         		; -- rows expected to be at the page boundary
     697/ 200 : 00                      rows:		DB	0b00000000	; row 1
     698/ 201 : 00                      		DB	0b00000000	; row 2
     699/ 202 : 00                      		DB	0b00000000	; row 3
     700/ 203 : 00                      		DB	0b00000000	; row 4
     701/ 204 : 00                      		DB	0b00000000	; row 5
     702/ 205 : 00                      		DB	0b00000000	; row 6
     703/ 206 : 00                      		DB	0b00000000	; row 7
     704/ 207 : 00                      		DB	0b00000000	; row 8
     705/ 208 :                         
     706/ 208 :                         		; a safety buffer
     707/ 208 : 00                      		DB	0		; recursion touches this cell
     708/ 209 :                         
     709/ 209 : 1B 5B 37 6D 00          esc_inv:	DB	"\x1B[7m\0"
     710/ 20E : 1B 5B 30 6D 00          esc_norm:	DB	"\x1B[0m\0"
     711/ 213 : 20 1B 5B 31 6D 51 1B 5B queen:		DB	" \x1B[1mQ\x1B[2m \0"
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 13 - 01/02/25 11:59:34


          21B : 32 6D 20 00            
     712/ 21F : 20 20 20 00             field:		DB	"   \0"
     713/ 223 : 20 20 20 41 20 20 42 20 hdr_row:	DB	"   A  B  C  D  E  F  G  H\r\n\0"
          22B : 20 43 20 20 44 20 20 45
          233 : 20 20 46 20 20 47 20 20
          23B : 48 0D 0A 00            
     714/ 23F : 20 00                   row_start:	DB	" \0"
     715/ 241 : 0D 0A 00                row_end:	DB	"\r\n\0"
     716/ 244 : 0D 0A 4E 6F 20 6D 6F 72 no_more_sols:	DB	"\r\nNo more solutions found.\n\rPress <ENTER> to return to Monitor\r\n\0"
          24C : 65 20 73 6F 6C 75 74 69
          254 : 6F 6E 73 20 66 6F 75 6E
          25C : 64 2E 0A 0D 50 72 65 73
          264 : 73 20 3C 45 4E 54 45 52
          26C : 3E 20 74 6F 20 72 65 74
          274 : 75 72 6E 20 74 6F 20 4D
          27C : 6F 6E 69 74 6F 72 0D 0A
          284 : 00                     
     717/ 285 : 0D 0A 50 72 65 73 73 20 next_or_exit:	DB	"\r\nPress <ENTER> to look for the next solution, or <ESC> to return to the monitor\r\n\0"
          28D : 3C 45 4E 54 45 52 3E 20
          295 : 74 6F 20 6C 6F 6F 6B 20
          29D : 66 6F 72 20 74 68 65 20
          2A5 : 6E 65 78 74 20 73 6F 6C
          2AD : 75 74 69 6F 6E 2C 20 6F
          2B5 : 72 20 3C 45 53 43 3E 20
          2BD : 74 6F 20 72 65 74 75 72
          2C5 : 6E 20 74 6F 20 74 68 65
          2CD : 20 6D 6F 6E 69 74 6F 72
          2D5 : 0D 0A 00               
     718/ 2D8 :                         
     719/ 2D8 :                         ; -----------------------------------------------------------------------------
     720/ 2D8 :                         ; Reserve space for R6 stack
     721/ 2D8 :                         ; -----------------------------------------------------------------------------
     722/ 37F :                         	ORG	(vars+0x017F)	; SCRT stack is from 0x017F..0x0100
     723/ 37F :                         scrt_stack:
     724/ 37F :                         
     725/ 37F :                         ; -----------------------------------------------------------------------------
     726/ 37F :                         ; Reserve space for R2 stack
     727/ 37F :                         ; -----------------------------------------------------------------------------
     728/ 3FF :                         	ORG	(vars+0x01FF)	; R2 stack is from 0x01FF..0x0180
     729/ 3FF :                         stack:
     730/ 3FF :                         
     731/ 3FF :                         
     732/ 3FF :                         ; -----------------------------------------------------------------------------
     733/ 3FF :                         ; Monitor routines called by this program
     734/ 3FF :                         ; -----------------------------------------------------------------------------
     735/ 3FF :                         
     736/8000 :                         	ORG	0x8000		; monitor entry point
     737/8000 :                         monitor:			;
     738/8000 :                         
     739/80A3 :                         	ORG	0x80A3		; mon_get_ch
     740/80A3 :                         mon_get_ch:			;
     741/80A3 :                         
     742/8100 :                         	ORG	0x8100		; mon_put_ch
     743/8100 :                         mon_put_ch:				;
     744/8100 :                         
     745/8526 :                         	ORG	0x8526		; mon_put_str
     746/8526 :                         mon_put_str:			;
     747/8526 :                         
     748/8ADB :                         	ORG	0x8ADB		; SCRT call subroutine invoked by SEP R4 and using R6 as SP
     749/8ADB :                         mon_scrt_call:			;
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 14 - 01/02/25 11:59:34


     750/8ADB :                         
     751/8AED :                         	ORG	0x8AED		; SCRT return subroutine invoked by SEP R5 and using R6 as SP
     752/8AED :                         mon_scrt_return:		;
     753/8AED :                         
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 15 - 01/02/25 11:59:34


  Symbol Table (* = unused):
  --------------------------

*ARCHITECTURE :                                      "x86_64-unknown-linux" - |
*BITFUNCSINC :                    1 - | *CASESENSITIVE :                  0 - |
 CODE :                           0 C | *CONSTPI :     3.141592653589793239 - |
*DATE :                  "01/02/25" - |  ESC_INV :                      209 C |
 ESC_NORM :                     20E C | *FALSE :                          0 - |
 FIELD :                        21F C |  FIND_NEXT_POS_IN_ROW :          6F C |
 FIND_POS :                      39 C |  FIND_POS_PROC_ROW :             53 C |
 FIND_POS_RET :                  74 C |  FIND_USER_RESPONSE :            41 C |
*FLOATMAX :   1.18973149535725E4932 - | *HAS64 :                          1 - |
 HDR_ROW :                      223 C | *LISTON :                         1 - |
*MACEXP :                         7 - |  MAIN :                          21 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                "1802" - |
 MONITOR :                     8000 C |  MON_GET_CH :                  80A3 C |
 MON_PUT_CH :                  8100 C |  MON_PUT_STR :                 8526 C |
 MON_SCRT_CALL :               8ADB C |  MON_SCRT_RETURN :             8AED C |
*NESTMAX :                      100 - |  NEXT_OR_EXIT :                 285 C |
 NO_MORE_SOLS :                 244 C |  NO_MORE_SOLUTIONS :             33 C |
 PRINT_BOARD :                  100 C |  PRINT_CRLF_AND_RET :           177 C |
 PRINT_CURRENT_FIELD :          151 C |  PRINT_CURRENT_ROW :            129 C |
 PRINT_ESC_INV :                14C C |  PRINT_FIELD_CONTENT :          161 C |
*PRINT_NEXT_FIELD :             169 C |  PRINT_QUEEN :                  15E C |
 PRINT_ROW :                    116 C |  PUT_STR :                      18A C |
 QUEEN :                        213 C |  R0 :                             0 - |
*R1 :                             1 - |  R2 :                             2 - |
 R3 :                             3 - |  R4 :                             4 - |
 R5 :                             5 - |  R6 :                             6 - |
 R7 :                             7 - |  R8 :                             8 - |
 R9 :                             9 - |  RA :                            0A - |
 RB :                            0B - | *RC :                            0C - |
*RD :                            0D - | *RE :                            0E - |
*RELAXED :                        1 - |  RF :                            0F - |
 ROWS :                         200 C |  ROW_END :                      241 C |
 ROW_START :                    23F C |  SCRT_STACK :                   37F C |
 STACK :                        3FF C | *START :                          0 C |
 TEST_COL :                      75 C |  TEST_COL_LOOP :                 83 C |
 TEST_COL_RET :                  8F C |  TEST_LEFT_DIAG :                9A C |
 TEST_LEFT_DIAG_LOOP :          0AB C |  TEST_LEFT_DIAG_RET :           0BB C |
 TEST_RIGHT_DIAG :              0C6 C |  TEST_RIGHT_DIAG_LOOP :         0D7 C |
 TEST_RIGHT_DIAG_RET :          0E7 C | *TIME :                  "11:59:34" - |
*TRUE :                           1 - |  VARS :                         200 C |
*VERSION :                     142F - |

     80 symbols
     23 unused symbols

 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 16 - 01/02/25 11:59:34


  Defined Functions:
  ------------------

ROTRN                                 | ROTLN                                
SHRN                                  | SHLN                                 
GETBIT                                | EVEN                                 
ODD                                   | LOWORD                               
HIWORD                                | LO                                   
HI                                    | CUTOUT                               
INVMASK                               | MASK                                 

 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 17 - 01/02/25 11:59:34


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.02 seconds assembly time

    834 lines source file
      2 passes
      0 errors
      0 warnings
