 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 1 - 01/02/25 11:01:20


       1/   0 :                         ; -----------------------------------------------------------------------------
       2/   0 :                         ; SPDX-FileCopyrightText: © 2025 Damir Maleničić,
       3/   0 :                         ; SPDX-License-Identifier: MIT
       4/   0 :                         ; -----------------------------------------------------------------------------
       5/   0 :                         ; 8 Queen Problem
       6/   0 :                         ; The program to find all 92 solutions for the
       7/   0 :                         ; [8 Queen Problem](https://en.wikipedia.org/wiki/Eight_queens_puzzle)
       8/   0 :                         ; and prints them to the connected console.
       9/   0 :                         ; -----------------------------------------------------------------------------
      10/   0 :                         ; The program is written for 1802 Membership Card revision L1 running Chuck
      11/   0 :                         ; Yakym's MS20ANSJ Monitor v2.0JR (10 Jul 2024) located at address 0x8000.
      12/   0 :                         ;
      13/   0 :                         ; It is assembled using
      14/   0 :                         ; [The Macro Assembler AS](http://john.ccac.rwth-aachen.de:8000/as/), but
      15/   0 :                         ; the code should be portable to other 1802 assemblers.
      16/   0 :                         ; The following are the assembling and linking instructions:
      17/   0 :                         ; ```
      18/   0 :                         ; asl -cpu 1802 -L 8-queens.asm
      19/   0 :                         ; p2hex 8-queens.p 8-queens.hex
      20/   0 :                         ; ```
      21/   0 :                         ; -----------------------------------------------------------------------------
      22/   0 :                         ; Register convention imposed by the integration with Chuck's monitor:
      23/   0 :                         ; R0 - reset program counter and SP, PC and SP for user program invoked with
      24/   0 :                         ;      'R' command, DMA memory pointer
      25/   0 :                         ; R1 - interrupt program counter
      26/   0 :                         ; R2 - stack pointer for main and interrupt routines
      27/   0 :                         ; R3 - program counter for main routine
      28/   0 :                         ; R4 - program counter for SCRT subroutine calls
      29/   0 :                         ; R5 - program counter for SCRT subroutine returns
      30/   0 :                         ; R6 - SCRT return address stack
      31/   0 :                         ; R7 - a pointer to a string to be written when invoking 8526
      32/   0 :                         ; RB.HI - holds the input character classification
      33/   0 :                         ; RB.LO - holds the input character, or the output character
      34/   0 :                         ; RE.HI - holds 01
      35/   0 :                         ; RE.LO - holds the baud rate indicator
      36/   0 :                         ; RF.HI - used by SCRT call and return subroutines to preserve the value of D
      37/   0 :                         ;         register between caller and callee
      38/   0 :                         ; -----------------------------------------------------------------------------
      39/   0 :                         ; Monitor routines used by this program (routine names are mine)
      40/   0 :                         ; 8000 - `monitor` entry point
      41/   0 :                         ; 80A3 - `mon_get_ch` reads a character and classifies it as:
      42/   0 :                         ;        00 - CR, 1 - space, 02 - ESC, 03 - digit, 04 - hex-letter or FF - other
      43/   0 :                         ; 8526 - `mon_put_str` writes a string to the screen. R7 points to the string.
      44/   0 :                         ;        R7 is preserved after the call.
      45/   0 :                         ; 8ADB - SCRT call a subroutine (invoked with R4 as PC)
      46/   0 :                         ; 8AED - SCRT return from a subroutine (invoked with R5 as PC)
      47/   0 :                         ; -----------------------------------------------------------------------------
      48/   0 :                         
      49/   0 :                         
      50/   0 :                         ; enable C style numeric constants --------------------------------------------
      51/   0 :                         
      52/   0 :                         
      53/   0 :                         	RELAXED	ON
      54/   0 :                         
      55/   0 :                         
      56/   0 :                         ; include the bit manipulation functions --------------------------------------
      57/   0 :                         ; This file defines a couple of bit-oriented functions that might be hardwired
      58/   0 :                         ; when using other assemblers.
      59/   0 :                         ; A code uses `hi()` and `lo()` operators that `asl` implements as user-defined
      60/   0 :                         ; function. $ is the synonym for the current PC address.
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 2 - 01/02/25 11:01:20


      61/   0 :                         ; The source for `bitfuncs.inc` is provided to help port those functions to the
      62/   0 :                         ; assembler of your choice.
      63/   0 :                         
      64/   0 :                         
      65/   0 :                         	INCLUDE "bitfuncs.inc"
(1)    1/   0 : =>UNDEFINED             		ifndef   bitfuncsinc    ; avoid multiple inclusion
(1)    2/   0 : =1H                     bitfuncsinc     equ      1
(1)    3/   0 :                         
(1)    4/   0 :                                         save
(1)   77/   0 : ALL                                     restore                 ; allow listing again
(1)   78/   0 :                         
(1)   79/   0 : [1]                                     endif			; bitfuncsinc
(1)   80/   0 :                         
(1)   81/   0 :                         
      66/   0 :                         
      67/   0 :                         
      68/   0 :                         ; register aliases ------------------------------------------------------------
      69/   0 : =0H                     R0	EQU	0
      70/   0 : =1H                     R1	EQU	1
      71/   0 : =2H                     R2	EQU	2
      72/   0 : =3H                     R3	EQU	3
      73/   0 : =4H                     R4	EQU	4
      74/   0 : =5H                     R5	EQU	5
      75/   0 : =6H                     R6	EQU	6
      76/   0 : =7H                     R7	EQU	7
      77/   0 : =8H                     R8	EQU	8
      78/   0 : =9H                     R9	EQU	9
      79/   0 : =0AH                    RA	EQU	10
      80/   0 : =0BH                    RB	EQU	11
      81/   0 : =0CH                    RC	EQU	12
      82/   0 : =0DH                    RD	EQU	13
      83/   0 : =0EH                    RE	EQU	14
      84/   0 : =0FH                    RF	EQU	15
      85/   0 :                         
      86/   0 :                         
      87/   0 :                         	ORG	0
      88/   0 :                         code:
      89/   0 :                         
      90/   0 :                         	; -----------------------------------------------------------------------------
      91/   0 :                         	; Initialize the program
      92/   0 :                         	; -----------------------------------------------------------------------------
      93/   0 :                         	; When started after reset, or by executing the monitor R0000 command:
      94/   0 :                         	; R0 is set to be both the program counter and the stack pointer
      95/   0 :                         	; R1 is  pointer.
      96/   0 :                         	; R2 is will become stack pointer in a case of an interrupt
      97/   0 :                         	; Following section configures the registers:
      98/   0 :                         	; R2 to point to the area that will become a stack pointer when control is passed to main
      99/   0 :                         	; R3 to point to main, it will become a program counter
     100/   0 :                         	; R4 will point to SCRT call routine
     101/   0 :                         	; R5 will point to SCRT return routine
     102/   0 :                         	; R6 will point to SCRT stack
     103/   0 :                         	; -----------------------------------------------------------------------------
     104/   0 :                         start:
     105/   0 :                         	; initialize R4 to 0x8ADB and R5 to 0x8AED to enable SCRT
     106/   0 : F8 8A                   	LDI	hi(mon_scrt_call)
     107/   2 : B4                      	PHI	R4
     108/   3 : B5                      	PHI	R5
     109/   4 : F8 DB                   	LDI	lo(mon_scrt_call)
     110/   6 : A4                      	PLO	R4
     111/   7 : F8 ED                   	LDI	lo(mon_scrt_return)
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 3 - 01/02/25 11:01:20


     112/   9 : A5                      	PLO	R5
     113/   A :                         
     114/   A :                         	; initialize R6 to SCRT_stack
     115/   A : F8 03                   	LDI	hi(scrt_stack)
     116/   C : B6                      	PHI	R6
     117/   D : F8 7F                   	LDI	lo(scrt_stack)
     118/   F : A6                      	PLO	R6
     119/  10 :                         
     120/  10 :                         	; configure R3 to point to the main
     121/  10 : F8 21                   	LDI	lo(main)
     122/  12 : A3                      	PLO	R3
     123/  13 : 90                      	GHI	R0
     124/  14 : B3                      	PHI	R3
     125/  15 :                         
     126/  15 :                         	; configure R2 to point to the stack
     127/  15 : F8 03                   	LDI	hi(stack)
     128/  17 : B2                      	PHI	R2
     129/  18 : F8 FF                   	LDI	lo(stack)
     130/  1A : A2                      	PLO	R2
     131/  1B :                         
     132/  1B :                         	; pass the control to main
     133/  1B : E2                      	SEX	R2			; Make R2 the default index register i.e. stack pointer
     134/  1C : D3                      	SEP	R3			; this will call main, while R0 still
     135/  1D :                         
     136/  1D :                         	; -----------------------------------------------------------------------------
     137/  1D :                         	; The program exit point
     138/  1D :                         	; -----------------------------------------------------------------------------
     139/  1D :                         	; R0 is pointing to this location so when SEP 0 is executed at the end of main,
     140/  1D :                         	; the program execution will resume at this point
     141/  1D : E0                      	SEX	R0			; Make R0 default index register like on reset
     142/  1E : C0 80 00                	LBR	monitor			; jump to monitor
     143/  21 :                         
     144/  21 :                         	; -----------------------------------------------------------------------------
     145/  21 :                         	; The main routine
     146/  21 :                         	; -----------------------------------------------------------------------------
     147/  21 :                         main:
     148/  21 :                         	; initialize
     149/  21 : F8 02                   	LDI	hi(rows)		; get address of the first row
     150/  23 : B8                      	PHI	R8			; initialize page address for all variable pointers
     151/  24 : F8 00                   	LDI	lo(rows)		; get address of the first row
     152/  26 : A8                      	PLO	R8			; R8 points to the first row
     153/  27 :                         
     154/  27 :                         	; set the initial values for the first recursive call
     155/  27 : F8 80                   	LDI	0x80			; initial cell of the first row
     156/  29 : 58                      	STR	R8			; store it to the memory
     157/  2A : F8 08                   	LDI	8			; number of rows to process
     158/  2C : BA                      	PHI	RA			; store it to RA.HI
     159/  2D : F8 00                   	LDI	0			; the first row is the current row
     160/  2F : AA                      	PLO	RA			; RA.LO holds the current row
     161/  30 :                         
     162/  30 :                         	; call the recursive routine to find 8-queen positions
     163/  30 : D4                      	SEP	R4
     164/  31 : 00                      	DB	hi(find_pos)
     165/  32 : 39                      	DB	lo(find_pos)
     166/  33 :                         
     167/  33 :                         	; no_more_solutions or user has cancelled the process, print the appropriate
     168/  33 :                         	; message to ask a user to press <ENTER> to return to monitor
     169/  33 :                         no_more_solutions:
     170/  33 : D4                      	SEP	R4
     171/  34 : 01                      	DB	hi(put_str)
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 4 - 01/02/25 11:01:20


     172/  35 : 8A                      	DB	lo(put_str)
     173/  36 : 02                      	DB	hi(no_more_sols)
     174/  37 : 44                      	DB	lo(no_more_sols)
     175/  38 :                         
     176/  38 :                         	; -----------------------------------------------------------------------------
     177/  38 :                         	; return the control to the program exit point
     178/  38 :                         	; -----------------------------------------------------------------------------
     179/  38 : D0                      	SEP	R0
     180/  39 :                         
     181/  39 :                         
     182/  39 :                         	; -----------------------------------------------------------------------------
     183/  39 :                         	; Find position
     184/  39 :                         	; -----------------------------------------------------------------------------
     185/  39 :                         	; Routine specific register usage:
     186/  39 :                         	; Input:
     187/  39 :                         	; R8 - points to current row representation
     188/  39 :                         	; RA.HI - holds number of rows to process
     189/  39 :                         	; RA.LO - the current row index
     190/  39 :                         	; RB - user interaction
     191/  39 :                         	; Output:
     192/  39 :                         	; RF.LO - 1 if position found, 0 if not
     193/  39 :                         	; -----------------------------------------------------------------------------
     194/  39 :                         find_pos:
     195/  39 :                         	; test if all 8 rows have been successfully processed?
     196/  39 : 8A                      	GLO	RA			; get current row value and check if it is 8?
     197/  3A : FD 08                   	SDI	8			; D = 8 - D i.e. will be 0 if all rows are processed
     198/  3C : 3A 53                   	BNZ	find_pos_proc_row	; if it is not the last row, continue processing current row
     199/  3E :                         
     200/  3E :                         	; last row processed - print the solution
     201/  3E : D4                      	SEP	R4
     202/  3F : 01                      	DB	hi(print_board)
     203/  40 : 00                      	DB	lo(print_board)
     204/  41 :                         
     205/  41 :                         	; inform and ask a user to press <ENTER> to look for the next solution or <ESC> to return to monitor
     206/  41 :                         find_user_response:
     207/  41 :                         	; write message to the user
     208/  41 : D4                      	SEP	R4
     209/  42 : 01                      	DB	hi(put_str)
     210/  43 : 8A                      	DB	lo(put_str)
     211/  44 : 02                      	DB	hi(next_or_exit)
     212/  45 : 85                      	DB	lo(next_or_exit)
     213/  46 :                         
     214/  46 :                         	; read user's response, on return, RB.HI will be 0 for <ENTER> or 2 for <ESC>
     215/  46 : D4                      	SEP	R4
     216/  47 : 80                      	DB	hi(mon_get_ch)
     217/  48 : A3                      	DB	lo(mon_get_ch)
     218/  49 :                         
     219/  49 :                         	; check if <ENTER>
     220/  49 : 9B                      	GHI	RB			; RB.HI is 0 if user pressed <ENTER>
     221/  4A : 32 74                   	BZ	find_pos_ret		; return to the previous level look for the next solution
     222/  4C :                         
     223/  4C :                         	; check if <ESC>
     224/  4C : FF 02                   	SMI	2			; if ESC was pressed RB.HI
     225/  4E : 3A 41                   	BNZ	find_user_response	; not the <ESC> key, invalid input let user try again
     226/  50 : C0 00 33                	LBR	no_more_solutions	; drop from all recursive calls and return to monitor
     227/  53 :                         
     228/  53 :                         	; process current row
     229/  53 :                         find_pos_proc_row:
     230/  53 :                         	; check if the queen at current position in the current row is attacking any other queen
     231/  53 : D4                      	SEP	R4			; test if attacking a queen in the same column
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 5 - 01/02/25 11:01:20


     232/  54 : 00                      	DB	hi(test_col)
     233/  55 : 75                      	DB	lo(test_col)
     234/  56 : 8F                      	GLO	RF
     235/  57 : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     236/  59 : D4                      	SEP	R4			; test if attacking a queen in the up-left diagonal
     237/  5A : 00                      	DB	hi(test_left_diag)
     238/  5B : 9A                      	DB	lo(test_left_diag)
     239/  5C : 8F                      	GLO	RF
     240/  5D : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     241/  5F : D4                      	SEP	R4			; test if attacking a queen in the up-right diagonal
     242/  60 : 00                      	DB	hi(test_right_diag)
     243/  61 : C6                      	DB	lo(test_right_diag)
     244/  62 : 8F                      	GLO	RF
     245/  63 : 32 6F                   	BZ	find_next_pos_in_row	; yes - try the next position
     246/  65 :                         
     247/  65 :                         	; no - found a safe position for the current row, move to next row recursively
     248/  65 : 18                      	INC	R8			; move the current row state pointer to the next row
     249/  66 : F8 80                   	LDI	0x80			; define the initial state for the next row
     250/  68 : 58                      	STR	R8			; and store it
     251/  69 : 1A                      	INC	RA			; increase the current row indicator
     252/  6A : D4                      	SEP	R4			; call recursively the routine to find the valid position in a new row
     253/  6B : 00                      	DB	hi(find_pos)
     254/  6C : 39                      	DB	lo(find_pos)
     255/  6D : 2A                      	DEC	RA			; on return restore the current row indicator
     256/  6E : 28                      	DEC	R8			; and restore the pointer to current row state
     257/  6F :                         
     258/  6F :                         	; try the next position in the current row if the current row is not exhausted
     259/  6F :                         find_next_pos_in_row:
     260/  6F : 08                      	LDN	R8			; get row state
     261/  70 : F6                      	SHR				; next row state
     262/  71 : 58                      	STR	R8			; save new row state
     263/  72 : 3B 53                   	BNF	find_pos_proc_row	; if it is not 0 after rotation, the stat is valid and loop to test it
     264/  74 :                         	; otherwise return back to the previous row
     265/  74 :                         
     266/  74 :                         find_pos_ret:
     267/  74 : D5                      	SEP	R5			; return from the subroutine
     268/  75 :                         
     269/  75 :                         
     270/  75 :                         	; ---------------------------------------------------------------------
     271/  75 :                         	; Test if attacking any other queen in the current column
     272/  75 :                         	; ---------------------------------------------------------------------
     273/  75 :                         	; Routine specific register usage:
     274/  75 :                         	; Input:
     275/  75 :                         	; R8 - points to current state row representation
     276/  75 :                         	; RA.LO - indicates the current row number
     277/  75 :                         	; Output:
     278/  75 :                         	; RF.LO - 1 if not attacking any other queen in the current column, 0 otherwise
     279/  75 :                         	; Internal usage (values preserved):
     280/  75 :                         	; RA.HI - the working copy of the the test mask
     281/  75 :                         	; R8 - points to row we test against
     282/  75 :                         	; D and DF are not preserved
     283/  75 :                         	; ---------------------------------------------------------------------
     284/  75 :                         test_col:
     285/  75 :                         	; save the registers that may be modified
     286/  75 : 9A                      	GHI	RA			; save RA on stack
     287/  76 : 73                      	STXD
     288/  77 : 8A                      	GLO	RA
     289/  78 : 73                      	STXD
     290/  79 : 98                      	GHI	R8			; save R8 on stack
     291/  7A : 73                      	STXD
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 6 - 01/02/25 11:01:20


     292/  7B : 88                      	GLO	R8
     293/  7C : 73                      	STXD
     294/  7D :                         
     295/  7D :                         	; initialize the test
     296/  7D : E8                      	SEX	R8			; make R8 a temporary SP
     297/  7E : F8 01                   	LDI	1			; assume the positive result
     298/  80 : AF                      	PLO	RF
     299/  81 : 08                      	LDN	R8			; take the current row state
     300/  82 : BA                      	PHI	RA			; preserve it in RA.HI as the test mask
     301/  83 :                         
     302/  83 :                         	; testing loop
     303/  83 :                         test_col_loop:
     304/  83 : 8A                      	GLO	RA			; are we in the top row?
     305/  84 : 32 8F                   	BZ	test_col_ret		; yes, then we are done
     306/  86 : 28                      	DEC	R8			; otherwise point to the previous row
     307/  87 : 2A                      	DEC	RA			; decrease testing row counter
     308/  88 : 9A                      	GHI	RA			; get the test mask
     309/  89 : F2                      	AND				; check if it overlaps with the testing row state
     310/  8A : 32 83                   	BZ	test_col_loop		; no, proceed to test with the row above
     311/  8C : F8 00                   	LDI	0			; yes, the test has failed
     312/  8E : AF                      	PLO	RF			; so indicate the negative result in the return value
     313/  8F :                         
     314/  8F :                         	; restore to the state before the call
     315/  8F :                         test_col_ret:
     316/  8F : E2                      	SEX	R2			; restore the stack pointer to R2
     317/  90 : 60                      	IRX				; drop SP to point the saved registers
     318/  91 : 72                      	LDXA				; restore R8
     319/  92 : A8                      	PLO	R8
     320/  93 : 72                      	LDXA
     321/  94 : B8                      	PHI	R8
     322/  95 : 72                      	LDXA				; restore RA
     323/  96 : AA                      	PLO	RA
     324/  97 : F0                      	LDX
     325/  98 : BA                      	PHI	RA
     326/  99 : D5                      	SEP	R5			; return
     327/  9A :                         
     328/  9A :                         
     329/  9A :                         	; ---------------------------------------------------------------------
     330/  9A :                         	; Test if attacking any other queen in the up-left diagonal
     331/  9A :                         	; ---------------------------------------------------------------------
     332/  9A :                         	; Routine specific register usage:
     333/  9A :                         	; Input:
     334/  9A :                         	; R8 - points to current state row representation
     335/  9A :                         	; RA.LO - indicates the current row number
     336/  9A :                         	; Output:
     337/  9A :                         	; RF.LO - 1 if not attacking any other queen in the diagonal, 0 otherwise
     338/  9A :                         	; Internal usage (values preserved):
     339/  9A :                         	; RA.HI - the working copy of the the test mask
     340/  9A :                         	; R8 - points to row we test against
     341/  9A :                         	; D and DF are not preserved
     342/  9A :                         	; ---------------------------------------------------------------------
     343/  9A :                         test_left_diag:
     344/  9A :                         	; save the registers that may be modified
     345/  9A : 9A                      	GHI	RA			; save RA on stack
     346/  9B : 73                      	STXD
     347/  9C : 8A                      	GLO	RA
     348/  9D : 73                      	STXD
     349/  9E : 98                      	GHI	R8			; save R8 on stack
     350/  9F : 73                      	STXD
     351/  A0 : 88                      	GLO	R8
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 7 - 01/02/25 11:01:20


     352/  A1 : 73                      	STXD
     353/  A2 :                         
     354/  A2 :                         	; initialize the test
     355/  A2 : E8                      	SEX	R8			; make R8 a temporary SP
     356/  A3 : F8 00                   	LDI	0			; make sure DF is 0 so we test only one position per row
     357/  A5 : FE                      	SHL
     358/  A6 : F8 01                   	LDI	1			; assume the positive result
     359/  A8 : AF                      	PLO	RF
     360/  A9 : 08                      	LDN	R8			; take current row state
     361/  AA : BA                      	PHI	RA			; preserve it in RA.HI as the initial test mask
     362/  AB :                         
     363/  AB :                         	; testing loop
     364/  AB :                         test_left_diag_loop:
     365/  AB : 8A                      	GLO	RA			; are we in the top row?
     366/  AC : 32 BB                   	BZ	test_left_diag_ret	; yes, then we are done
     367/  AE : 28                      	DEC	R8			; no, point to the previous row
     368/  AF : 2A                      	DEC	RA			; decrease testing row counter
     369/  B0 : 9A                      	GHI	RA			; get the test mask
     370/  B1 : FE                      	SHL				; shift mask left
     371/  B2 : 33 BB                   	BDF	test_left_diag_ret	; if shifted out of the board we are done
     372/  B4 : BA                      	PHI	RA			; preserve the test maks for the next iteration
     373/  B5 : F2                      	AND				; check if it overlaps with the testing row state
     374/  B6 : 32 AB                   	BZ	test_left_diag_loop	; no, proceed to test with the row above
     375/  B8 : F8 00                   	LDI	0			; yes, the test has failed
     376/  BA : AF                      	PLO	RF			; so indicate the negative result in the return value
     377/  BB :                         
     378/  BB :                         test_left_diag_ret:
     379/  BB :                         	; restore to the state before the call
     380/  BB : E2                      	SEX	R2			; restore the stack pointer
     381/  BC : 60                      	IRX				; drop SP to point the saved registers
     382/  BD : 72                      	LDXA				; restore R8
     383/  BE : A8                      	PLO	R8
     384/  BF : 72                      	LDXA
     385/  C0 : B8                      	PHI	R8
     386/  C1 : 72                      	LDXA				; restore RA
     387/  C2 : AA                      	PLO	RA
     388/  C3 : F0                      	LDX
     389/  C4 : BA                      	PHI	RA
     390/  C5 : D5                      	SEP	R5			; return
     391/  C6 :                         
     392/  C6 :                         
     393/  C6 :                         	; ---------------------------------------------------------------------
     394/  C6 :                         	; Test if attacking any other queen in the up-right diagonal
     395/  C6 :                         	; ---------------------------------------------------------------------
     396/  C6 :                         	; Routine specific register usage:
     397/  C6 :                         	; Input:
     398/  C6 :                         	; R8 - points to current state row representation
     399/  C6 :                         	; RA.LO - indicates the current row number
     400/  C6 :                         	; Output:
     401/  C6 :                         	; RF.LO - 1 if not attacking any other queen in the diagonal, 0 otherwise
     402/  C6 :                         	; Internal usage (values preserved):
     403/  C6 :                         	; RA.HI - the working copy of the the test mask
     404/  C6 :                         	; R8 - points to row we test against
     405/  C6 :                         	; D and DF are not preserved
     406/  C6 :                         	; ---------------------------------------------------------------------
     407/  C6 :                         test_right_diag:
     408/  C6 : 9A                      	GHI	RA			; save RA on stack
     409/  C7 : 73                      	STXD
     410/  C8 : 8A                      	GLO	RA
     411/  C9 : 73                      	STXD
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 8 - 01/02/25 11:01:20


     412/  CA : 98                      	GHI	R8			; save R8 on stack
     413/  CB : 73                      	STXD
     414/  CC : 88                      	GLO	R8
     415/  CD : 73                      	STXD
     416/  CE :                         
     417/  CE :                         	; initialize the test
     418/  CE : E8                      	SEX	R8			; make R8 a temporary SP
     419/  CF : F8 00                   	LDI	0			; make sure DF is 0 so we test only one position per row
     420/  D1 : F6                      	SHR
     421/  D2 : F8 01                   	LDI	1			; assume the positive result
     422/  D4 : AF                      	PLO	RF
     423/  D5 : 08                      	LDN	R8			; take current row state
     424/  D6 : BA                      	PHI	RA			; preserve it in RA.HI as the initial test mask
     425/  D7 :                         
     426/  D7 :                         	; testing loop
     427/  D7 :                         test_right_diag_loop:
     428/  D7 : 8A                      	GLO	RA			; are we in the top row?
     429/  D8 : 32 E7                   	BZ	test_right_diag_ret	; yes, then we are done
     430/  DA : 28                      	DEC	R8			; no, point to the previous row
     431/  DB : 2A                      	DEC	RA			; decrease testing row counter
     432/  DC : 9A                      	GHI	RA			; get the test mask
     433/  DD : F6                      	SHR				; shift mask right
     434/  DE : 33 E7                   	BDF	test_right_diag_ret	; if shifted out of board we are done
     435/  E0 : BA                      	PHI	RA			; preserve the test maks for the next iteration
     436/  E1 : F2                      	AND				; check if it overlaps with the testing row state
     437/  E2 : 32 D7                   	BZ	test_right_diag_loop	; no, proceed to test with the row above
     438/  E4 : F8 00                   	LDI	0			; yes, the test has failed
     439/  E6 : AF                      	PLO	RF			; so indicate the negative result in the return value
     440/  E7 :                         
     441/  E7 :                         test_right_diag_ret:
     442/  E7 :                         	; restore to the state before the call
     443/  E7 : E2                      	SEX	R2			; restore the stack pointer
     444/  E8 : 60                      	IRX				; drop SP to point the saved registers
     445/  E9 : 72                      	LDXA				; restore R8
     446/  EA : A8                      	PLO	R8
     447/  EB : 72                      	LDXA
     448/  EC : B8                      	PHI	R8
     449/  ED : 72                      	LDXA				; restore RA
     450/  EE : AA                      	PLO	RA
     451/  EF : F0                      	LDX
     452/  F0 : BA                      	PHI	RA
     453/  F1 : D5                      	SEP	R5			; return
     454/  F2 :                         
     455/  F2 :                         
     456/ 100 :                         	ORG	0x0100
     457/ 100 :                         
     458/ 100 :                         	; -----------------------------------------------------------------------------
     459/ 100 :                         	; Print the result
     460/ 100 :                         	; -----------------------------------------------------------------------------
     461/ 100 :                         	; Routine specific register usage:
     462/ 100 :                         	; Input registers: none
     463/ 100 :                         	; Output registers: none
     464/ 100 :                         	; Internal usage (values preserved):
     465/ 100 :                         	; R8 - points to the current row
     466/ 100 :                         	; R9.LO - the working copy of the current chessboard row content
     467/ 100 :                         	; RA.HI - the number of rows to print
     468/ 100 :                         	; D and DF are not preserved
     469/ 100 :                         	; -----------------------------------------------------------------------------
     470/ 100 :                         print_board:
     471/ 100 :                         	; preserve R8, R9.LO, RA.HI
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 9 - 01/02/25 11:01:20


     472/ 100 : 98                      	GHI	R8
     473/ 101 : 73                      	STXD
     474/ 102 : 88                      	GLO	R8
     475/ 103 : 73                      	STXD
     476/ 104 : 89                      	GLO	R9
     477/ 105 : 73                      	STXD
     478/ 106 : 8A                      	GLO	RA
     479/ 107 : 73                      	STXD
     480/ 108 :                         
     481/ 108 :                         	; initialize printing
     482/ 108 : F8 08                   	LDI	8			; number or chessboard rows to print
     483/ 10A : BA                      	PHI	RA			; store it to RA.HI
     484/ 10B : F8 02                   	LDI	hi(rows)		; get address of the first row
     485/ 10D : B8                      	PHI	R8
     486/ 10E : F8 00                   	LDI	lo(rows)
     487/ 110 : A8                      	PLO	R8			; R8 points to the first row
     488/ 111 :                         
     489/ 111 :                         	; print the header row
     490/ 111 : D4                      	SEP	R4
     491/ 112 : 01                      	DB	hi(put_str)
     492/ 113 : 8A                      	DB	lo(put_str)
     493/ 114 : 02                      	DB	hi(hdr_row)
     494/ 115 : 23                      	DB	lo(hdr_row)
     495/ 116 :                         
     496/ 116 :                         	; the row printing loop
     497/ 116 :                         print_row:
     498/ 116 :                         	; print a current row content
     499/ 116 : D4                      	SEP	R4			; print row, on return R8 will point to the next row
     500/ 117 : 01                      	DB	hi(print_current_row)
     501/ 118 : 29                      	DB	lo(print_current_row)
     502/ 119 : 9A                      	GHI	RA			; get the number of rows to process
     503/ 11A : FF 01                   	SMI	1			; decrease it
     504/ 11C : BA                      	PHI	RA			; preserve the value
     505/ 11D : 3A 16                   	BNZ	print_row		; if it is no 0 continue with the next row
     506/ 11F :                         
     507/ 11F :                         	; restore RA.LO, R9.LO, R8
     508/ 11F : 60                      	IRX				; drop SP to point the saved registers
     509/ 120 : 72                      	LDXA
     510/ 121 : AA                      	PLO	RA
     511/ 122 : 72                      	LDXA
     512/ 123 : A9                      	PLO	R9
     513/ 124 : 72                      	LDXA
     514/ 125 : A8                      	PLO	R8
     515/ 126 : F0                      	LDX
     516/ 127 : B8                      	PHI	R8
     517/ 128 :                         	; return
     518/ 128 : D5                      	SEP	R5
     519/ 129 :                         
     520/ 129 :                         
     521/ 129 :                         	; -----------------------------------------------------------------------------
     522/ 129 :                         	; Print current chessboard row
     523/ 129 :                         	; -----------------------------------------------------------------------------
     524/ 129 :                         	; Routine specific register usage:
     525/ 129 :                         	; Input:
     526/ 129 :                         	; R8 - points to the current row
     527/ 129 :                         	; Output:
     528/ 129 :                         	; R8 - points to the next row
     529/ 129 :                         	; Internal usage (values preserved):
     530/ 129 :                         	; R7 - points to a string to be printed using monitor routine at 0x8526
     531/ 129 :                         	; R9.HI - the number of (remaining) chessboard fields in the current row to print
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 10 - 01/02/25 11:01:20


     532/ 129 :                         	; R9.LO - working copy of the current row content
     533/ 129 :                         	; RA.LO - indicator if the current print is black or white
     534/ 129 :                         	; RB.LO - a character to print using `mon_put_ch`
     535/ 129 :                         	; -----------------------------------------------------------------------------
     536/ 129 :                         print_current_row:
     537/ 129 :                         	; preserve R7, R9, RA.LO, RB.LO
     538/ 129 : 97                      	GHI	R7
     539/ 12A : 73                      	STXD
     540/ 12B : 87                      	GLO	R7
     541/ 12C : 73                      	STXD
     542/ 12D : 99                      	GHI	R9
     543/ 12E : 73                      	STXD
     544/ 12F : 89                      	GLO	R9
     545/ 130 : 73                      	STXD
     546/ 131 : 8A                      	GLO	RA
     547/ 132 : 73                      	STXD
     548/ 133 : 8B                      	GLO	RB
     549/ 134 : 73                      	STXD
     550/ 135 :                         
     551/ 135 :                         	; print row number
     552/ 135 : 9A                      	GHI	RA		; load remaining number of rows to print into D
     553/ 136 : FD 39                   	SDI	'9'		; D = '9' - D, subtract current row number from '9'
     554/ 138 : AB                      	PLO	RB		; put result in RB.LO for printing
     555/ 139 : D4                      	SEP	R4		; invoke mon_put_ch routine to print the character in RB.LO
     556/ 13A : 81                      	DB	hi(mon_put_ch)
     557/ 13B : 00                      	DB	lo(mon_put_ch)
     558/ 13C :                         
     559/ 13C :                         	; print a space between the row number and the first field
     560/ 13C : D4                      	SEP	R4
     561/ 13D : 01                      	DB	hi(put_str)
     562/ 13E : 8A                      	DB	lo(put_str)
     563/ 13F : 02                      	DB	hi(row_start)
     564/ 140 : 3F                      	DB	lo(row_start)
     565/ 141 :                         
     566/ 141 :                         	; initialize the field counter, row pointer, black-white indicator
     567/ 141 : F8 08                   	LDI	8	; 8 chessboard fields in a row
     568/ 143 : B9                      	PHI	R9	; R9.HI holds a number of chessboard fields in a row to print
     569/ 144 : 48                      	LDA	R8	; Load content of the current row then make R8 points to the next row
     570/ 145 : A9                      	PLO	R9	; R9.LO holds ca working copy of the current row
     571/ 146 : 88                      	GLO	R8	; Test if it is an odd or an even row? The odd rows start with a white cell.
     572/ 147 : FA 01                   	ANI	01	; Is it even or odd row?
     573/ 149 : AA                      	PLO	RA	; Store this info in RA.LO so we can invert it for the next iteration
     574/ 14A : 32 51                   	BZ	print_current_field	; If it is an even row skip sending invert video esc sequence
     575/ 14C :                         
     576/ 14C :                         	; print invert video escape sequence
     577/ 14C :                         print_esc_inv:
     578/ 14C : D4                      	SEP	R4
     579/ 14D : 01                      	DB	hi(put_str)
     580/ 14E : 8A                      	DB	lo(put_str)
     581/ 14F : 02                      	DB	hi(esc_inv)
     582/ 150 : 09                      	DB	lo(esc_inv)
     583/ 151 :                         
     584/ 151 :                         	; print the current field
     585/ 151 :                         print_current_field:
     586/ 151 :                         	; load page holding strings representing board content to R7.HI, R7.LO will depend on content to print
     587/ 151 : F8 02                   	LDI	hi(field)
     588/ 153 : B7                      	PHI	R7
     589/ 154 :                         
     590/ 154 :                         	; determine the current field content depending if the corresponding row bit is 1 (a queen) or 0 (an empty field)
     591/ 154 : 89                      	GLO	R9		; get the working copy of the current row
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 11 - 01/02/25 11:01:20


     592/ 155 : FE                      	SHL			; shift D left putting msb in the DF
     593/ 156 : A9                      	PLO	R9		; store the new state of the working copy of the current row for the next iteration
     594/ 157 : 33 5E                   	BDF	print_queen	; if the DF is 1 the field contains the queen
     595/ 159 :                         
     596/ 159 :                         	; get string representing an empty field into R7
     597/ 159 : F8 1F                   	LDI	lo(field)
     598/ 15B : A7                      	PLO	R7
     599/ 15C : 30 61                   	BR	print_field_content
     600/ 15E :                         
     601/ 15E :                         	; get string representing a field with queen into R7
     602/ 15E :                         print_queen:
     603/ 15E : F8 13                   	LDI	lo(queen)
     604/ 160 : A7                      	PLO	R7
     605/ 161 :                         
     606/ 161 :                         	; print the current field
     607/ 161 :                         print_field_content:
     608/ 161 : D4                      	SEP	R4
     609/ 162 : 85                      	DB	hi(mon_put_str)
     610/ 163 : 26                      	DB	lo(mon_put_str)
     611/ 164 :                         
     612/ 164 :                         	; undo the inverse video and bold-face font if either or both were set by printing norm esc sequence
     613/ 164 : D4                      	SEP	R4
     614/ 165 : 01                      	DB	hi(put_str)
     615/ 166 : 8A                      	DB	lo(put_str)
     616/ 167 : 02                      	DB	hi(esc_norm)
     617/ 168 : 0E                      	DB	lo(esc_norm)
     618/ 169 :                         
     619/ 169 :                         	; prepare for printing the next field
     620/ 169 :                         print_next_field:
     621/ 169 : 99                      	GHI	R9		; get the number of fields to print in the current row
     622/ 16A : FF 01                   	SMI	1		; decrease it
     623/ 16C : 32 77                   	BZ	print_crlf_and_ret	; if the result is 0 print <CR><LF> and return
     624/ 16E : B9                      	PHI	R9		; otherwise preserve the number of fields left to print for the next iteration
     625/ 16F : 8A                      	GLO	RA		; get the black-white field indicator
     626/ 170 : FB 01                   	XRI	1		; invert it
     627/ 172 : AA                      	PLO	RA		; and preserve the result for the next iteration
     628/ 173 : 32 51                   	BZ	print_current_field	; if it was black go to directly printing a field content
     629/ 175 : 30 4C                   	BR	print_esc_inv	; if it was white, go to printing video invert esc sequence first
     630/ 177 :                         
     631/ 177 :                         	; print <CR><LF> sequence
     632/ 177 :                         print_crlf_and_ret:
     633/ 177 : D4                      	SEP	R4
     634/ 178 : 01                      	DB	hi(put_str)
     635/ 179 : 8A                      	DB	lo(put_str)
     636/ 17A : 02                      	DB	hi(row_end)
     637/ 17B : 41                      	DB	lo(row_end)
     638/ 17C :                         
     639/ 17C :                         	; restore RB.LO, RA.LO, R9, R7
     640/ 17C : 60                      	IRX
     641/ 17D : 72                      	LDXA
     642/ 17E : AB                      	PLO	RB
     643/ 17F : 72                      	LDXA
     644/ 180 : AA                      	PLO	RA
     645/ 181 : 72                      	LDXA
     646/ 182 : A9                      	PLO	R9
     647/ 183 : 72                      	LDXA
     648/ 184 : B9                      	PHI	R9
     649/ 185 : 72                      	LDXA
     650/ 186 : A7                      	PLO	R7
     651/ 187 : F0                      	LDX
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 12 - 01/02/25 11:01:20


     652/ 188 : B7                      	PHI	R7
     653/ 189 :                         	; return
     654/ 189 : D5                      	SEP	R5
     655/ 18A :                         
     656/ 18A :                         
     657/ 18A :                         	; -----------------------------------------------------------------------------
     658/ 18A :                         	; The wrapper for `mon_put_str` to enable passing string address inline with
     659/ 18A :                         	; a subroutine call
     660/ 18A :                         	; -----------------------------------------------------------------------------
     661/ 18A :                         	; Internal usage (values preserved):
     662/ 18A :                         	; R7 - hold pointer to the string when invoking the `mon_put_str` routine
     663/ 18A :                         	; -----------------------------------------------------------------------------
     664/ 18A :                         put_str:
     665/ 18A :                         	; preserve R7 register
     666/ 18A : 97                      	GHI	R7
     667/ 18B : 73                      	STXD
     668/ 18C : 87                      	GLO	R7
     669/ 18D : 73                      	STXD
     670/ 18E :                         
     671/ 18E :                         	; load inline string address into R7
     672/ 18E : 46                      	LDA	R6
     673/ 18F : B7                      	PHI	R7
     674/ 190 : 46                      	LDA	R6
     675/ 191 : A7                      	PLO	R7
     676/ 192 :                         
     677/ 192 :                         	; call mon_put_str routine from the monitor that expects R7 to point to the string
     678/ 192 : D4                      	SEP	R4
     679/ 193 : 85                      	DB	hi(mon_put_str)
     680/ 194 : 26                      	DB	lo(mon_put_str)
     681/ 195 :                         
     682/ 195 :                         	; restore R7 register
     683/ 195 : 60                      	IRX
     684/ 196 : 72                      	LDXA
     685/ 197 : A7                      	PLO	R7
     686/ 198 : F0                      	LDX
     687/ 199 : B7                      	PHI	R7
     688/ 19A :                         	; return
     689/ 19A : D5                      	SEP	R5
     690/ 19B :                         
     691/ 19B :                         
     692/ 200 :                         		ORG	(code+0x0200)
     693/ 200 :                         vars:
     694/ 200 :                         		; -- rows expected to be at the page boundary
     695/ 200 : 00                      rows:		DB	0b00000000	; row 1
     696/ 201 : 00                      		DB	0b00000000	; row 2
     697/ 202 : 00                      		DB	0b00000000	; row 3
     698/ 203 : 00                      		DB	0b00000000	; row 4
     699/ 204 : 00                      		DB	0b00000000	; row 5
     700/ 205 : 00                      		DB	0b00000000	; row 6
     701/ 206 : 00                      		DB	0b00000000	; row 7
     702/ 207 : 00                      		DB	0b00000000	; row 8
     703/ 208 :                         
     704/ 208 :                         		; a safety buffer
     705/ 208 : 00                      		DB	0		; recursion touches this cell
     706/ 209 :                         
     707/ 209 : 1B 5B 37 6D 00          esc_inv:	DB	"\x1B[7m\0"
     708/ 20E : 1B 5B 30 6D 00          esc_norm:	DB	"\x1B[0m\0"
     709/ 213 : 20 1B 5B 31 6D 51 1B 5B queen:		DB	" \x1B[1mQ\x1B[2m \0"
          21B : 32 6D 20 00            
     710/ 21F : 20 20 20 00             field:		DB	"   \0"
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 13 - 01/02/25 11:01:20


     711/ 223 : 20 20 20 41 20 20 42 20 hdr_row:	DB	"   A  B  C  D  E  F  G  H\r\n\0"
          22B : 20 43 20 20 44 20 20 45
          233 : 20 20 46 20 20 47 20 20
          23B : 48 0D 0A 00            
     712/ 23F : 20 00                   row_start:	DB	" \0"
     713/ 241 : 0D 0A 00                row_end:	DB	"\r\n\0"
     714/ 244 : 0D 0A 4E 6F 20 6D 6F 72 no_more_sols:	DB	"\r\nNo more solutions found.\n\rPress <ENTER> to return to Monitor\r\n\0"
          24C : 65 20 73 6F 6C 75 74 69
          254 : 6F 6E 73 20 66 6F 75 6E
          25C : 64 2E 0A 0D 50 72 65 73
          264 : 73 20 3C 45 4E 54 45 52
          26C : 3E 20 74 6F 20 72 65 74
          274 : 75 72 6E 20 74 6F 20 4D
          27C : 6F 6E 69 74 6F 72 0D 0A
          284 : 00                     
     715/ 285 : 0D 0A 50 72 65 73 73 20 next_or_exit:	DB	"\r\nPress <ENTER> to look for the next solution, or <ESC> to return to the monitor\r\n\0"
          28D : 3C 45 4E 54 45 52 3E 20
          295 : 74 6F 20 6C 6F 6F 6B 20
          29D : 66 6F 72 20 74 68 65 20
          2A5 : 6E 65 78 74 20 73 6F 6C
          2AD : 75 74 69 6F 6E 2C 20 6F
          2B5 : 72 20 3C 45 53 43 3E 20
          2BD : 74 6F 20 72 65 74 75 72
          2C5 : 6E 20 74 6F 20 74 68 65
          2CD : 20 6D 6F 6E 69 74 6F 72
          2D5 : 0D 0A 00               
     716/ 2D8 :                         
     717/ 2D8 :                         ; -----------------------------------------------------------------------------
     718/ 2D8 :                         ; Reserve space for R6 stack
     719/ 2D8 :                         ; -----------------------------------------------------------------------------
     720/ 37F :                         	ORG	(vars+0x017F)	; SCRT stack is from 0x017F..0x0100
     721/ 37F :                         scrt_stack:
     722/ 37F :                         
     723/ 37F :                         ; -----------------------------------------------------------------------------
     724/ 37F :                         ; Reserve space for R2 stack
     725/ 37F :                         ; -----------------------------------------------------------------------------
     726/ 3FF :                         	ORG	(vars+0x01FF)	; R2 stack is from 0x01FF..0x0180
     727/ 3FF :                         stack:
     728/ 3FF :                         
     729/ 3FF :                         
     730/ 3FF :                         ; -----------------------------------------------------------------------------
     731/ 3FF :                         ; Monitor routines called by this program
     732/ 3FF :                         ; -----------------------------------------------------------------------------
     733/ 3FF :                         
     734/8000 :                         	ORG	0x8000		; monitor entry point
     735/8000 :                         monitor:			;
     736/8000 :                         
     737/80A3 :                         	ORG	0x80A3		; mon_get_ch
     738/80A3 :                         mon_get_ch:			;
     739/80A3 :                         
     740/8100 :                         	ORG	0x8100		; mon_put_ch
     741/8100 :                         mon_put_ch:				;
     742/8100 :                         
     743/8526 :                         	ORG	0x8526		; mon_put_str
     744/8526 :                         mon_put_str:			;
     745/8526 :                         
     746/8ADB :                         	ORG	0x8ADB		; SCRT call subroutine invoked by SEP R4 and using R6 as SP
     747/8ADB :                         mon_scrt_call:			;
     748/8ADB :                         
     749/8AED :                         	ORG	0x8AED		; SCRT return subroutine invoked by SEP R5 and using R6 as SP
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 14 - 01/02/25 11:01:20


     750/8AED :                         mon_scrt_return:		;
     751/8AED :                         
 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 15 - 01/02/25 11:01:20


  Symbol Table (* = unused):
  --------------------------

*ARCHITECTURE :                                      "x86_64-unknown-linux" - |
*BITFUNCSINC :                    1 - | *CASESENSITIVE :                  0 - |
 CODE :                           0 C | *CONSTPI :     3.141592653589793239 - |
*DATE :                  "01/02/25" - |  ESC_INV :                      209 C |
 ESC_NORM :                     20E C | *FALSE :                          0 - |
 FIELD :                        21F C |  FIND_NEXT_POS_IN_ROW :          6F C |
 FIND_POS :                      39 C |  FIND_POS_PROC_ROW :             53 C |
 FIND_POS_RET :                  74 C |  FIND_USER_RESPONSE :            41 C |
*FLOATMAX :   1.18973149535725E4932 - | *HAS64 :                          1 - |
 HDR_ROW :                      223 C | *LISTON :                         1 - |
*MACEXP :                         7 - |  MAIN :                          21 C |
*MOMCPU :                      1802 - | *MOMCPUNAME :                "1802" - |
 MONITOR :                     8000 C |  MON_GET_CH :                  80A3 C |
 MON_PUT_CH :                  8100 C |  MON_PUT_STR :                 8526 C |
 MON_SCRT_CALL :               8ADB C |  MON_SCRT_RETURN :             8AED C |
*NESTMAX :                      100 - |  NEXT_OR_EXIT :                 285 C |
 NO_MORE_SOLS :                 244 C |  NO_MORE_SOLUTIONS :             33 C |
 PRINT_BOARD :                  100 C |  PRINT_CRLF_AND_RET :           177 C |
 PRINT_CURRENT_FIELD :          151 C |  PRINT_CURRENT_ROW :            129 C |
 PRINT_ESC_INV :                14C C |  PRINT_FIELD_CONTENT :          161 C |
*PRINT_NEXT_FIELD :             169 C |  PRINT_QUEEN :                  15E C |
 PRINT_ROW :                    116 C |  PUT_STR :                      18A C |
 QUEEN :                        213 C |  R0 :                             0 - |
*R1 :                             1 - |  R2 :                             2 - |
 R3 :                             3 - |  R4 :                             4 - |
 R5 :                             5 - |  R6 :                             6 - |
 R7 :                             7 - |  R8 :                             8 - |
 R9 :                             9 - |  RA :                            0A - |
 RB :                            0B - | *RC :                            0C - |
*RD :                            0D - | *RE :                            0E - |
*RELAXED :                        1 - |  RF :                            0F - |
 ROWS :                         200 C |  ROW_END :                      241 C |
 ROW_START :                    23F C |  SCRT_STACK :                   37F C |
 STACK :                        3FF C | *START :                          0 C |
 TEST_COL :                      75 C |  TEST_COL_LOOP :                 83 C |
 TEST_COL_RET :                  8F C |  TEST_LEFT_DIAG :                9A C |
 TEST_LEFT_DIAG_LOOP :          0AB C |  TEST_LEFT_DIAG_RET :           0BB C |
 TEST_RIGHT_DIAG :              0C6 C |  TEST_RIGHT_DIAG_LOOP :         0D7 C |
 TEST_RIGHT_DIAG_RET :          0E7 C | *TIME :                  "11:01:20" - |
*TRUE :                           1 - |  VARS :                         200 C |
*VERSION :                     142F - |

     80 symbols
     23 unused symbols

 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 16 - 01/02/25 11:01:20


  Defined Functions:
  ------------------

ROTRN                                 | ROTLN                                
SHRN                                  | SHLN                                 
GETBIT                                | EVEN                                 
ODD                                   | LOWORD                               
HIWORD                                | LO                                   
HI                                    | CUTOUT                               
INVMASK                               | MASK                                 

 AS V1.42 Beta [Bld 281] - Source File 8-queens.asm - Page 17 - 01/02/25 11:01:20


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.04 seconds assembly time

    832 lines source file
      2 passes
      0 errors
      0 warnings
